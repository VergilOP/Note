# Node of Operational System

## Week 6



### Additional Exercises

1. How does the distinction between kernel mode and user mode function as a rudimentary form  
   > The kernel mode can do check. The user mode can access the memory units which are allowed to access(you know which process you are working from/for).

2. Which of the following instructions should be privileged  
   1. Set value of timer  
   > Yes, every process need to use timer (so it will affect a lot)
   2. Read the clock  
   > No, write need privileged but reed doesn't
   3. Clear memory 
   > if clear the OWN memory don't need privileged else need
   4. Issue a trap instruction  
   > Yes, you might jump to the part you shouldn't be
   5. Turn off interrupts  
   > Yes, without interrupts the system may out of control
   6. Modify entries in device-status table
   > No
   7. Switch from user to kernel mode  (√)
   8. Access I/O device

3. Why is it important not to have memory leaks in the kernel?  
   The memory of kernel is every small, so memory leaks in the kernel may result errors

4. What is the effect of calling a routine which may send the current process to sleep in interrupt mode?  
   The current process will be interrupted and the system will process the routine. After the routine is done. The current process will be woked up and processed

### Programming Exercise
1. Write a program which creates a new file and writes the numbers from 1 to 100 into it  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <string.h>
    #include <errno.h>
    int main(){
        int fileDescriptor;
        int buffer[100];
        int i;
        int res;
        // 0 USER GROUP OTHER
        // Read(R): 4     Write(W): 2    Execute(X):1
        fileDescriptor = open("myFile.txt", O_RDWR | O_CREADT, 0644);
        if(fileDescriptor < 0){
            // print error message
            perror("Opening failed");
            exit(1);
        }
        for (i = 0; i < 100; i++){
            buffer[i] = i + 1;
        }
        res = write(fileDescriptor, buffer, sizeof(int) * 100);
        if(res < 0){
            perror("writing failed");
    	    close(fileDescriptor);
    	    exit(1);
        }
        printf ("%d bytes written\n", res);
        res = close(fileDescriptor);
        if(res < 0){
            perror("closing failed");
    	    exit(1);
        }
        return 0;
    }
    ```

## Week 7

### Additional Exercises

1. MCQS
    1. The mapping of a logical address to a physical address is done in hardware by \_A\_.  
        A) memory management unit(MMU)  
        B) memory address register  
        C) relocation register  
        D) dynamic loading register
        > A register is not sufficient for this mapping
    2. In a dynamically linked library, \_D\_.  
        A) loading is postponed until execution time  
        B) system language libraries are treated like any other object module  
        C) more disk space is used than in a statically linked library  
        D) a stub is included in the image for each library-routine reference  
        > The stub checks whether the library code is already in main memory and loads it if not
    3. An address generated by a CPU is referred to as a \_B\_.  
        A) physical address  
        B) logical address  
        C) post relocation register address  
        D) memory management unit(MMU) generated address  
        > The logical addresses are translated by the MMU into physical address
    4. Consider a logical address with a page size of 8 KB. How many bits must be used to represent the page offset in the logical address? \_C\_  
        A) 10  
        B) 8  
        C) 13  
        D) 12  
        > 2^13 = 8192
    5. Consider a logical address with 18 bits used to represent an entry in a conventional page table. How many entries are in the conventional page table? \_A\_  
        A) 262144  
        B) 1024  
        C) 1048576  
        D) 18
        > We need 2^18 = 262144 entries
    6. What is the context switch time, associated with swapping, if a disk drive with a transfer rate of 2MB/s is used to swap out part of a program this is 200KB in size? Assume that no seeks are necessary and that the average latency is 15ms. \_A\_  
        A) 300  
        B) 115  
        C) 155  
        D) None of the above  
        > The answer is 115 ms - 100ms for the data transfer and 15ms latency

2. 
   1. [Part 1] Consider a paging system with the page table stored in memory.
         1. If a memory reference takes 200 nanoseconds, how long does a paged memory reference take?  
            > 400 nanoseconds - we need to acces main memory twice
         2. Suppose we have associative registers where finding a page-table entry (if present) takes zero time, and which contains 75% of all page-table references. What will be the effective memory reference time in this case
            > 200 ns + 0.25*200 ns = 250 ns
         3. Suppose the time to find an entry in associative registers in 2 ns. What will be the access time?
            > 250 ns + 0.75 * 2 ns = 251.5 ns

3. [Virtual Memory]. Consider a demand-paged computer system where the degree of multiprogramming is currently fixed at 4. The system was recently measured to determine utilization of CPU and the paging disk. The results are one of the following alternatives. For each case, what is happening? \_\_  
    A) CPU utilization 13 percent; disk utilization 97 percent  
    > Thrashing: the CPU is swapping pages to and from disk.

    B) CPU utilization 87 percent; disk utilization 3 percent  
    > At least one CPU-intensive programming is running.  

    C) CPU utilization 13 percent; disk utilization 3 percent  
    > Underused system with spare capacity.  

### Programming Exercise

1. Extend the device driver such that writing to the device sets the counter to the value written, which is an integer. You will have to decide whether you want to write integers as strings or as numbers to the kern
    ```c
    // Int
    device_write(struct file *filp, const char *buff, size_t len, loff_t * off)
    {
        if (len < sizeof(int)) {
    	printk(KERN_INFO "Integer expected\n");
    	return -EINVAL;
        }

        if (copy_from_user(&counter, buff, sizeof(int))) {
    	printk(KERN_ALERT "Copying from user failed.\n");
    	return -EPERM;
        }
        printk(KERN_INFO "New counter value is %d\n", counter);
        return len;
    }

    //String
    static ssize_t
    device_write(struct file *filp, const char *buff, size_t len, loff_t * off)
    {

        char *kbuff;

        printk(KERN_INFO "Buffer length = %ld\n", len);
        kbuff = kmalloc(len+1, GFP_KERNEL);
        if (kbuff == NULL) {
    	printk(KERN_ALERT "Cannot allocate kernel memory\n");
    	return -ENOMEM;
        }
        if (copy_from_user(kbuff, buff, len)) {
    	printk(KERN_ALERT "Copying from user failed.\n");
    	kfree(kbuff);
    	return -EPERM;
        }
        kbuff[len] = '\0'; // prevent buffer overflow
        if (kstrtol(kbuff, 10, &counter)) {
    	printk(KERN_INFO "Not an integer: %s\n", kbuff);
    	kfree(kbuff);
    	return -EINVAL;
        }
        kfree(kbuff);
        return len;
    }
    ```

## Week 8

### Additional Exercises

1. Is it a good idea to have access to peripheral devices as part of a critical section
    > No - the access operation can take some time, and may even sleep.
2. Are race conditions possible if there is only one process runing at the same time?
    > Yes - because the scheduler might re-empt one process and run another one.
3. Can the C-compiler find race conditions?
    > No - race conditions cannot be prevented by checking the syntax of a program.
4. Is it possible for testing to show the absence of race conditions?
    > No - as it is impossible to create all posible sequences in which programs can be executed.
5. A program has no deadlock when only function 1 or function 2, but never function 1 and function 2, are executed. Can you guarantee that the program still has no deadlock when function and function 2 are both executed?
    > No - deadlock is a global property. You will need to check function1 and function2 together to rule out deadlocks

## Week 9

### Additional Exercises


## Mock Exam

### Question 1

1. Will there be any memory leakage in the following program? Explain your answer.

    ```c
    int main()
    {
        int *A = (int *) malloc(sizeof(int));
        scanf("%d", A);
        int *B;
        B = A;
        free(B);
        return 0;
    }
    ```
    > The program will not leak memory   
    > 先说出结论 (2 marks)  
    > The allocated memory-block is pointed by A and later by both A and B. Hence, both A and B contain the same address. free(B) is the same as free(A) and hence there will be no memory leak.  
    > 分配空间指向A然后A和B -> 所以共享同一个地址 -> 所以free(B)等于free(A) -> 所以无内存泄漏 (4 marks)

2. A programmer has written the following function with the aim to return a pointer to an array of 10 random integers (int) to a caller function. There is a serious problem with this code. Expain what is wrong, why it is a problem, and how it can be fixed. Use this to write a correct version of the function without changing the function-signature. Assume that the caller function of `randomArray` is responsible for freeing any memory occupied by the array.

    ```c
    int* randomArray(void)
    {
        int array[10], i;
        for (i = 0; i < 10; i++)
            array[i] = rand();
        return &array[0];
    }
    ```
    > The array is allocated in the stack frame of randomArray(), hence it is a local object. The array object is only in scope during the excution of the function. At the completion of a randomArray() function call, the stack frame will be deallocated and the local array object will be out of scope.  
    > If the function returns a pointer to an out-of-scope array object, then the pointerd data will not be reliable and hence the program output will not be reliable  
    > Instead of creating a local array object in the stack fram, the function should allocate the array in the heap and then return a pointer to the heap-based array.  
    > 解释错误 (3 marks)
    ```c
    int* randomArray(void)
    {
        int *array, i;
        array = (int *) malloc (10*sizeof(int));
        for (i = 0; i < 10; ++i)
            array[i] = rand();
        return array;
    }
    ```
    > 纠正代码 (4 marks)

3. Consider the following two C functions `sum2Darray1` and `sum2Darray2`. Both of them compute the sum of all the elements of an input 2-demesional matrix. Which one of them will be able to exploit memory hierarchy and thus achieve faster computation time? Explain your answer.

    ```c
    int sum2Darray1(int a[N][M])
    {
        int i, j, sum = 0;
        for(i=0;i<m;i++)
            for(j=0;j<N;j++)
                sum = sum + a[j][i];
        return sum;
    }

    int sum2Darray2(int a[N][M])
    {
        int i, j, sum = 0;
        for(i=0;i<m;i++)
            for(j=0;j<N;j++)
                sum = sum + a[i][j];
        return sum;
    }
    ```
    > Modern computers with memory hierarchy try to speedup computation by applying the principles of temporal and spatial locality. Thus, when a program tries to read one int object from the main memory, other adjacent int objects are also brought to the cache.  
    > *identifying the fastest strategy (2 marks)*  
    > The function `sum2Darray1` reads the matrix elements along the columns. Whereas `sum2Darray2` reads the matrix elements along the rows. Since, the C programming language stores a 2D matrix in the row-major order, `sum2Darray2` offers better spatial locality  compared to `sum2Darray1`, and thus offers better performance.  
    > *explanation (5 marks)*  
    > Hence, Strategy2 will be more efficient
    > 总结