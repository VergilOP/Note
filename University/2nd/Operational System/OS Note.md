# Node of Operational System

## Week 6

### Additional Exercises

1. How does the distinction between kernel mode and user mode function as a rudimentary form of protection(security) system
   > All CPU instructions which might affect other users or access devices directly may be only executed in kernel mode. Hence the operating system can prevent user 1 from executing instructions which might affect user 2

2. Which of the following instructions should be privileged  
   1. Set value of timer  
        > Yes, every process need to use timer (so it will affect a lot)
   2. Read the clock  
        > No, write need privileged but read doesn't
   3. Clear memory 
        > No, if it clears the `OWN` memory don't need privileged, otherwise, yes
   4. Issue a trap instruction  
        > Yes, except the one used for issuing a system call, must not be privilieged
   5. Turn off interrupts  
        > Yes, without interrupts the system may out of control
   6. Modify entries in device-status table
        > Yes
   7. Switch from user to kernel mode
        > Yes, except the ones used in connection with system calls, should be unprivilieged
   8. Access I/O device
        > Yes

3. Why is it important not to have memory leaks in the kernel?  
   > The kernel never stops and has no grabage collector. Hence any memory lost to a memory leak will not be reclaimed(回收)

4. What is the effect of calling a routine which may send the current process to sleep in interrupt mode?  
   > The interrupt may occur while any process is executing. If the current process is sent to sleep, this process might not be woken up and therefore will never continue.

### Programming Exercise

1. Write a program which creates a new file and writes the numbers from 1 to 100 into it  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <string.h>
    #include <errno.h>
    int main(){
        int fileDescriptor;
        int buffer[100];
        int i;
        int res;
        // 0 USER GROUP OTHER
        // Read(R): 4     Write(W): 2    Execute(X):1
        fileDescriptor = open("myFile.txt", O_RDWR | O_CREADT, 0644);
        if(fileDescriptor < 0){
            // print error message
            perror("Opening failed");
            exit(1);
        }
        for (i = 0; i < 100; i++){
            buffer[i] = i + 1;
        }
        res = write(fileDescriptor, buffer, sizeof(int) * 100);
        if(res < 0){
            perror("writing failed");
    	    close(fileDescriptor);
    	    exit(1);
        }
        printf ("%d bytes written\n", res);
        res = close(fileDescriptor);
        if(res < 0){
            perror("closing failed");
    	    exit(1);
        }
        return 0;
    }
    ```

## Week 7

### Additional Exercises

1. MCQS
    1. The mapping of a logical address to a physical address is done in hardware by `A`.  
        `A) memory management unit(MMU)`  
        B) memory address register  
        C) relocation register  
        D) dynamic loading register
        > A register is not sufficient for this mapping. So we need a hardware which is MMU
    2. In a dynamically linked library, `D`.  
        A) loading is postponed(推迟) until execution time  
        B) system language libraries are treated like any other object module  
        C) more disk space is used than in a statically linked library  
        `D) a stub is included in the image for each library-routine reference`  
        > The stub checks whether the library code is already in main memory and loads it if not
    3. An address generated by a CPU is referred to as a `B`.  
        A) physical address  
        `B) logical address`  
        C) post relocation register address  
        D) memory management unit(MMU) generated address  
        > The logical addresses are translated by the MMU into physical address
    4. Consider a logical address with a page size of 8 KB. How many bits must be used to represent the page offset in the logical address? `C`  
        A) 10  
        B) 8  
        `C) 13`  
        D) 12  
        > 2^13 = 8192
    5. Consider a logical address with 18 bits used to represent an entry in a conventional page table. How many entries are in the conventional page table? `A`  
        `A) 262144`  
        B) 1024  
        C) 1048576  
        D) 18
        > We need 2^18 = 262144 entries
    6. What is the context switch time, associated with swapping, if a disk drive with a transfer rate of 2MB/s is used to swap out part of a program this is 200KB in size? Assume that no seeks are necessary and that the average latency is 15ms. `B`  
        A) 300  
        `B) 115`  
        C) 155  
        D) None of the above  
        > The answer is 115 ms - 100ms for the data transfer and 15ms latency

2. [Part 1] Consider a paging system with the page table stored in memory.
    1. If a memory reference takes 200 nanoseconds, how long does a paged memory reference take?  
       > 400 nanoseconds - we need to acces main memory twice
    2. Suppose we have associative registers where finding a page-table entry (if present) takes zero time, and which contains 75 of all page-table references. What will be the effective memory reference time in this case
       > 200 ns + 0.25*200 ns = 250 ns
    3. Suppose the time to find an entry in associative registers in 2 ns. What will be the access time?
       > 250 ns + 0.75 * 2 ns = 251.5 ns

3. [Virtual Memory]. Consider a demand-paged computer system where the degree of multiprogramming is currently fixed at 4. The system was recently measured to determine utilization of CPU and the paging disk. The results are one of the following alternatives. For each case, what is happening?   
    A) CPU utilization 13 percent; disk utilization 97 percent  
    > Thrashing: the CPU is `swapping pages` to and from disk.

    B) CPU utilization 87 percent; disk utilization 3 percent  
    > At least one `CPU-intensive` programming is running.  

    C) CPU utilization 13 percent; disk utilization 3 percent  
    > `Underused` system with spare capacity.  

### Programming Exercise

1. Extend the device driver such that writing to the device sets the counter to the value written, which is an integer. You will have to decide whether you want to write integers as strings or as numbers to the kern
    ```c
    // Int
    device_write(struct file *filp, const char *buff, size_t len, loff_t * off)
    {
        if (len < sizeof(int)) {
    	printk(KERN_INFO "Integer expected\n");
    	return -EINVAL;
        }

        if (copy_from_user(&counter, buff, sizeof(int))) {
    	printk(KERN_ALERT "Copying from user failed.\n");
    	return -EPERM;
        }
        printk(KERN_INFO "New counter value is %d\n", counter);
        return len;
    }

    //String
    static ssize_t
    device_write(struct file *filp, const char *buff, size_t len, loff_t * off)
    {

        char *kbuff;

        printk(KERN_INFO "Buffer length = %ld\n", len);
        kbuff = kmalloc(len+1, GFP_KERNEL);
        if (kbuff == NULL) {
    	printk(KERN_ALERT "Cannot allocate kernel memory\n");
    	return -ENOMEM;
        }
        if (copy_from_user(kbuff, buff, len)) {
    	printk(KERN_ALERT "Copying from user failed.\n");
    	kfree(kbuff);
    	return -EPERM;
        }
        kbuff[len] = '\0'; // prevent buffer overflow
        if (kstrtol(kbuff, 10, &counter)) {
    	printk(KERN_INFO "Not an integer: %s\n", kbuff);
    	kfree(kbuff);
    	return -EINVAL;
        }
        kfree(kbuff);
        return len;
    }
    ```

## Week 8

### Additional Exercises

1. Is it a good idea to have access to peripheral(外围) devices as part of a critical section
    > No - the access operation can take some time, and may even sleep.
2. Are race conditions possible if there is only one process runing at the same time?
    > Yes - because the scheduler might re-empt one process and run another one.
3. Can the C-compiler find race conditions?
    > No - race conditions cannot be prevented by checking the syntax of a program.
4. Is it possible for testing to show the absence of race conditions?
    > No - as it is impossible to create all posible sequences in which programs can be executed.
5. A program has no deadlock when only function 1 or function 2, but never function 1 and function 2, are executed. Can you guarantee that the program still has no deadlock when function and function 2 are both executed?
    > No - deadlock is a `global property`. You will need to check function1 and function2 together to rule out deadlocks

## Week 9

### Additional Exercises

1. The __ of a process contains temporary data such as function parameters, return addresses, and local variables. `D`  
    A) text section  
    B) data section  
    C) program counter  
    `D) stack`  
    > The text section contains the program code
    > The data section contains the heap
    > The program counter contains the address of the next insturction which is to be executed

2. The list of processes waiting for a particular I/O device is called a(n) __? `B`  
    A) standby queue  
    `B) device queue`  
    C) ready queue  
    D) interrupt queue  
    > **Job queue**: set of all processes in the system  
    > **Ready queue**: set of all processes residing in main memory, ready an waiting to execute  
    > **Device queues**: set of processes waiting for an I/O device

3. The __ refers to the number of processes in memory. `B`  
    A) process counter  
    `B) degree of multiprogramming`  
    C) CPU scheduler  
    > **process counter**: a register in a computer processor that contains the address(location) of the instruction beging executed at the current time.  
    > **degree of mutiprogramming**: The maximum number of processes that a single-processor system can accommodate efficiently.  
    > **CPU scheduler**: it will decide which of the ready, in-memory processes is to be executed(allocated a CPU) after an interrupt or system call.

4. When a child process is created, which of the following is a possibility in terms of the execution or address spce of the child process? `D`  
    A) The child process runs concurrently with the parent.  
    B) The child process has new program loaded into it  
    C) The child is a duplicate of the parent  
    `D) All of the above`  
    > All possibilities exist and are useful

5. A __ saves the state of the currently running process and restores the state of the next process to run. `C`  
    A) save-and-restore  
    B) state switch  
    `C) context switch`  
    D) none of the above  
    > **context switch** is the process of storing the the state of a process or thread, so that it can be restored and resume execution at a later point

6. A process may transition to the Ready state by which of the following actions? `D`  
    A) Completion of an I/O event  
    B) Awaiting its turn on the CPU  
    C) Newly-admitted process  
    `D) All of the above`  
    ) All transitions exist and are useful

7. A process that has terminated, but whose parent has not yet called wait(), is known as a __ process. `A`  
    `A) zombie`  
    B) orphan  
    C) terminated  
    D) init  
    > **zombie process**: Parent do not call `wait()` for exit(), so its entries are still in the process table  
    > **orphan process**: Parent completes before the complement of the child process

8. The __ process is assigned as the parent to orphan process. `B`  
    A) zombie  
    `B) init`  
    C) main  
    D) renderer  
    > In newer UNIX systems this can also be the systemd process

9. When a process creates a new process using the fork() operation, which of the following state is shared between the parent process and the child process? `C`  
    A) Stack  
    B) Heap  
    `C) Shared memory segments`  
    > Stack and Heap are copied when the fork system call is executed

10. Which of the following scheduling algorithms could result in starvation? `B,D`  
    A) First-come, first-served  
    `B) Shortest job first`  
    C) Round robin  
    `D) Priority`  
    > First-come, first-served cannot result in starvation if pre-emption is possible

11. The total number of child processes created by the following code(excluding Parent) is __. `B`  
    A) n  
    `B) 2^n-1`  
    C) 2^n  
    D) 2^(n+1)-1  
    > Each iteration doubles the number of processes created

12. True/False
    1.  All processes in UNIX first translate to a zombie process unpon termination. `True`
    2.  The difference between a program and a process is that a program is an active entity while a process is a passive entity. `False`
    3.  The exec() system call creates a new process. `False`

## Week 10

### Additional Exercises

1. Discuss how performance optimisations for file systems might result in difficulties in maintaining the consistency of the systems in the event of a computer crashes.
    > One very useful optimisation is to `store frequently` used directory entries in main memory and write them only periodically to the disk.  
    > One of those frequently used directories is `the root` of the file system. If the computer crashes before these directory entries have been written back to disk, the information on the disk is inconsistent

2. In what situations would using main memory for storing the content of a disk(called a RAM disk) be more useful than using it as a disk cache.
    > If the disk only contains temporary information which is not required after a restart, it doesen't matter if the information is lost when the system crashes. Therefore if enough RAM is available, it is very efficient to store the whole disk in RAM and only operate in RAM. This is ture (e.g. for /tmp on a UNIX system)

3. Some systems automatically open a file when it is references for the first time, and close the file when job terminates. Discuss the advantages and the disadvantages of this scheme. Compare it to the more traditional one, hwere the user has to open and close the file explicitly.
    > Opening and closing a file saves explicit system calls in user space and therefore makes programming easier.  
    > However, it is less efficient, as the overhead of making the device accessible and inaccessible is incurred for every read and write-operation.  
    > In addition, the kernel can maintain internal state(ie the current position in a file) when separate open and close-calls are used. If they are not used, the user has to maintain this internal state.

4. Consider a file system where a file can be deleted and its disk space reclaimed while links to that file still exist. What problems may occur if a new file is created in the same storage area or with the same absolute path name? How can these problems be avoided?
    > If the same storage is used for a new file, then inconsistencies might arise. If a file with the same absolute path name is re-created, it will be used as the target for the link. One possible solution is the way symbolic links are implemented in UNIX: A link points to a file identified by a filename, not an area on disk. If the file the link points to does not exist, all operations on this link fail. If a new file with the name the link points to is created, it is automatically used.

## Mock Exam

### Question 1

1. Will there be any memory leakage in the following program? Explain your answer.

    ```c
    int main()
    {
        int *A = (int *) malloc(sizeof(int));
        scanf("%d", A);
        int *B;
        B = A;
        free(B);
        return 0;
    }
    ```
    > The program will not leak memory   
    > 先说出结论 (2 marks)  
    > The allocated memory-block is pointed by A and later by both A and B. Hence, both A and B contain the same address. free(B) is the same as free(A) and hence there will be no memory leak.  
    > 分配空间指向A然后A和B -> 所以共享同一个地址 -> 所以free(B)等于free(A) -> 所以无内存泄漏 (4 marks)

2. A programmer has written the following function with the aim to return a pointer to an array of 10 random integers (int) to a caller function. There is a serious problem with this code. Expain what is wrong, why it is a problem, and how it can be fixed. Use this to write a correct version of the function without changing the function-signature. Assume that the caller function of `randomArray` is responsible for freeing any memory occupied by the array.

    ```c
    int* randomArray(void)
    {
        int array[10], i;
        for (i = 0; i < 10; i++)
            array[i] = rand();
        return &array[0];
    }
    ```
    > The array is allocated in the stack frame of randomArray(), hence it is a local object. The array object is only in scope during the excution of the function. At the completion of a randomArray() function call, the stack frame will be deallocated and the local array object will be out of scope.  
    > If the function returns a pointer to an out-of-scope array object, then the pointerd data will not be reliable and hence the program output will not be reliable  
    > Instead of creating a local array object in the stack fram, the function should allocate the array in the heap and then return a pointer to the heap-based array.  
    > 解释错误 (3 marks)
    ```c
    int* randomArray(void)
    {
        int *array, i;
        array = (int *) malloc (10*sizeof(int));
        for (i = 0; i < 10; ++i)
            array[i] = rand();
        return array;
    }
    ```
    > 纠正代码 (4 marks)

3. Consider the following two C functions `sum2Darray1` and `sum2Darray2`. Both of them compute the sum of all the elements of an input 2-demesional matrix. Which one of them will be able to exploit memory hierarchy and thus achieve faster computation time? Explain your answer.

    ```c
    int sum2Darray1(int a[N][M])
    {
        int i, j, sum = 0;
        for(i=0;i<m;i++)
            for(j=0;j<N;j++)
                sum = sum + a[j][i];
        return sum;
    }

    int sum2Darray2(int a[N][M])
    {
        int i, j, sum = 0;
        for(i=0;i<m;i++)
            for(j=0;j<N;j++)
                sum = sum + a[i][j];
        return sum;
    }
    ```
    > Modern computers with memory hierarchy try to speedup computation by applying the principles of temporal and spatial locality. Thus, when a program tries to read one int object from the main memory, other adjacent int objects are also brought to the cache.  
    > *identifying the fastest strategy (2 marks)*  
    > The function `sum2Darray1` reads the matrix elements along the columns. Whereas `sum2Darray2` reads the matrix elements along the rows. Since, the C programming language stores a 2D matrix in the row-major order, `sum2Darray2` offers better spatial locality  compared to `sum2Darray1`, and thus offers better performance.  
    > *explanation (5 marks)*  
    > Hence, Strategy2 will be more efficient
    > 总结