# Laziness

See also Chapter 15 of the book. This part of the module is optional (but we have mentioned laziness very often in various parts of the module already).

# Memoization

## A sample inefficient recursive definition

Consider again the (inefficiently defined) fibonacci function:

```haskell
fib :: Integer -> Integer
fib 0 = 1
fib 1 = 1
fib n = fib(n-2) + fib(n-1)
```
Here are some run times:
```
*Main> fib 10
89
(0.00 secs, 106,504 bytes)
*Main> fib 20
10946
(0.02 secs, 4,647,448 bytes)
*Main> fib 30
1346269
(1.30 secs, 562,665,480 bytes)
*Main> fib 35
14930352
(14.10 secs, 6,239,298,880 bytes)
*Main> fib 36
24157817
(22.98 secs, 10,095,351,920 bytes)
```
The run time grows rapidly because of the two recursive calls (picture the recursion tree in your mind).

## Recursion via the fixed-point combinator `fix`

```haskell
fix :: (a -> a) -> a
fix f = x
 where
   x = f x
```
This recursively defines `x`. We are often interested in the case
where `a` is a function type such as `b -> c`.

Using the fixed-point combinator `fix`, this function can be equivalently defined as
```haskell
fibstep :: (Integer -> Integer) -> (Integer -> Integer)
fibstep g = h
 where
  h :: Integer -> Integer
  h 0 = 1
  h 1 = 1
  h n = g(n-2) + g(n-1)

fib' :: Integer -> Integer
fib' = fix fibstep
```
This is the *recursion step* of the recursive definition of the fibonacci function. We have the following theorem:
```
    fib  = fibstep fib
    fib' = fibstep fib'
```
Notice that the functions `fibstep` and `g'` are not recursively
defined. The expression `fib n` has a very bad run-time, as discussed
in previous lectures, as its previous values are evaluated multiple
times, and so does `fib' n`.

The function `fib'` is just as inefficient as `fib` (try it).

## Memoizing fixed-point combinator

We can store a function from non-negative integers (natural numbers)
to a type `a` using an infinite lazy list:
```haskell
store :: (Integer -> a) -> [a]
store f = [f i | i <- [0..]]
```
and we can fetch it back:
```haskell
fetch :: [a] -> (Integer -> a)
fetch (x:xs) 0 = x
fetch (x:xs) n = fetch xs (n-1)
```
Composing the two functions we get a function
```haskell
memoList :: (Integer -> a) -> (Integer -> a)
memoList= fetch . store
```
We get the same function back (as far as its behaviour on non-negative integers is concerned).

Because of laziness, once an element of a list is computed, it stays
computed. Hence fibonacci becomes linear time if we define it as follows
```haskell
fibml :: Integer -> Integer
fibml = fix(memoList . fibstep)
```
We can package this into a memoizing fixed-point combinator:
```haskell
fixml :: ((Integer -> a) -> (Integer -> a)) -> Integer -> a
fixml f = g
 where
   g = f(memoList g)

fibml' :: Integer -> Integer
fibml' = fixml fibstep
```

The run-times of these two functions are essentially the same. We consider only one of them here:
```
*Main> fibml 36
24157817
(0.01 secs, 81,136 bytes)
*Main> fibml 40
165580141
(0.00 secs, 81,624 bytes)
*Main> fibml 1000
70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501
(0.01 secs, 401,640 bytes)
*Main> fibml 5000
6276302800488957086035253108349684055478528702736457439025824448927937256811663264475883711527806250329984690249846819800648580083040107584710332687596562185073640422286799239932615797105974710857095487342820351307477141875012176874307156016229965832589137779724973854362777629878229505500260477136108363709090010421536915488632339240756987974122598603591920306874926755600361865354330444681915154695741851960071089944015319300128574107662757054790648152751366475529121877212785489665101733755898580317984402963873738187000120737824193162011399200547424034440836239726275765901190914513013217132050988064832024783370583789324109052449717186857327239783000020791777804503930439875068662687670678802914269784817022567088069496231111407908953313902398529655056082228598715882365779469902465675715699187225655878240668599547496218159297881601061923195562143932693324644219266564617042934227893371179832389642895285401263875342640468017378925921483580111278055044254198382265567395946431803304304326865077742925818757370691726168228648841319231470626
(0.01 secs, 1,743,224 bytes)
*Main> fibml 7000
59290401041683102440672829867913655667177284295570856482398561497899821008702563191682998126031426336812106306157950903693625961895457384170707696682835766197328371194280639252048666840342756165707241417947420242697378891533795188046329595393191210531240060565669691090355554675684426078893238891967744248131920159453235952521741392043432587673611875481748108922547186431244384630788896864039536935986373707241808040178029318541658974563482015180045832433560416282392506941626027765846901546580645498583385947082515709759021966156694302163967228181963857196033927978205325677091875556898095362168737467286234929361473048571929070731035278109469637105238427067353589370555252072437832137325116232609084094119857782277762930276510778198545102132608654523230820214213223413253262152536487586016127170541558616361336459796253525130197989617401215344370451870534541778633740709451069694464340846574038923007948792018770003081000900989488674868924280328705835513270541923409590927087377786662137964358712449935932999270073566350124802448041925162432545419068421227627926451096281793602407729297437577123882514541609304240451360411586459516258968726904641720306998849760845004673569691520954034222213184219616630278401443367648547274130816953541402484168718023282530489333936594435575246397995335087475094557229181966721280933610166234689048759914493059299128721036649378672598520701870210041637179272281600351183604175949714000846069179391411115592194569269933878199501
(4.42 secs, 1,979,417,448 bytes)
```
This is very good. What happens is that because of lazy evaluation, each element of the infinite list is evaluated at most once, and once it is evaluated, it stays evaluated in the list. So a repeated call to the same value of the function doesn't require re-evaluation.

We want to make this even faster. But, before that, we consider a way to avoid the lists, by regarding the function itself as a list:
```haskell
type Sequence a = Integer -> a

hd :: Sequence a -> a
hd s = s 0

tl :: Sequence a -> Sequence a
tl s = \n -> s(n+1)

cons :: a -> Sequence a -> Sequence a
cons x s n | n == 0    = x
           | otherwise = s(n-1)

memoSeq :: Sequence a -> Sequence a
memoSeq s = cons (hd s) (memoSeq(tl s))

fibms :: Integer -> Integer
fibms = fix(memoSeq . fibstep)

```

This is still fast, but not as fast as with lists, but has the same time complexity:
```
*Main> fibms 36
24157817
(0.01 secs, 100,368 bytes)
*Main> fibms 40
165580141
(0.01 secs, 156,656 bytes)
*Main> fibms 1000
70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501
(0.41 secs, 251,874,976 bytes)
*Main> fibms 5000
6276302800488957086035253108349684055478528702736457439025824448927937256811663264475883711527806250329984690249846819800648580083040107584710332687596562185073640422286799239932615797105974710857095487342820351307477141875012176874307156016229965832589137779724973854362777629878229505500260477136108363709090010421536915488632339240756987974122598603591920306874926755600361865354330444681915154695741851960071089944015319300128574107662757054790648152751366475529121877212785489665101733755898580317984402963873738187000120737824193162011399200547424034440836239726275765901190914513013217132050988064832024783370583789324109052449717186857327239783000020791777804503930439875068662687670678802914269784817022567088069496231111407908953313902398529655056082228598715882365779469902465675715699187225655878240668599547496218159297881601061923195562143932693324644219266564617042934227893371179832389642895285401263875342640468017378925921483580111278055044254198382265567395946431803304304326865077742925818757370691726168228648841319231470626
(9.65 secs, 5,860,500,552 bytes)
*Main> fibms 7000
59290401041683102440672829867913655667177284295570856482398561497899821008702563191682998126031426336812106306157950903693625961895457384170707696682835766197328371194280639252048666840342756165707241417947420242697378891533795188046329595393191210531240060565669691090355554675684426078893238891967744248131920159453235952521741392043432587673611875481748108922547186431244384630788896864039536935986373707241808040178029318541658974563482015180045832433560416282392506941626027765846901546580645498583385947082515709759021966156694302163967228181963857196033927978205325677091875556898095362168737467286234929361473048571929070731035278109469637105238427067353589370555252072437832137325116232609084094119857782277762930276510778198545102132608654523230820214213223413253262152536487586016127170541558616361336459796253525130197989617401215344370451870534541778633740709451069694464340846574038923007948792018770003081000900989488674868924280328705835513270541923409590927087377786662137964358712449935932999270073566350124802448041925162432545419068421227627926451096281793602407729297437577123882514541609304240451360411586459516258968726904641720306998849760845004673569691520954034222213184219616630278401443367648547274130816953541402484168718023282530489333936594435575246397995335087475094557229181966721280933610166234689048759914493059299128721036649378672598520701870210041637179272281600351183604175949714000846069179391411115592194569269933878199501
(9.77 secs, 5,875,378,008 bytes)
```

The above two memoization functions introduce a linear-time overhead. We can use trees to
get a logarithmic overhead. [haskell wiki](https://wiki.haskell.org/Memoization#Memoizing_fix_point_operator)

But we can actually avoid the trees, by regarding a function `Integer
-> a` as a tree (where negative integers are ignored):
```haskell
type Tree a = Integer -> a

root :: Tree a -> a
root t = t 0

left, right :: Tree a -> Tree a
left t  = \n -> t(1+2*n)
right t = \n -> t(2+2*n)

fork :: a -> Tree a -> Tree a -> Tree a
fork x l r n | n == 0 = x
             | odd n  = l((n-1) `div` 2)
             | even n = r((n-2) `div` 2)

memoTree :: Tree a -> Tree a
memoTree t = fork (root t) (memoTree(left t)) (memoTree(right t))

fixt :: ((Integer -> a) -> (Integer -> a)) -> Integer -> a
fixt f = g
 where
   g = f(memoTree g)

fibmt :: Integer -> Integer
fibmt = fix(memoTree . fibstep)
```

As you can see, this gives a dramatic improvement:
```
*Main> fibmt 36
24157817
(0.01 secs, 78,024 bytes)
*Main> fibmt 40
165580141
(0.00 secs, 78,224 bytes)
*Main> fibmt 1000
70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501
(0.00 secs, 255,600 bytes)
*Main> fibmt 5000
6276302800488957086035253108349684055478528702736457439025824448927937256811663264475883711527806250329984690249846819800648580083040107584710332687596562185073640422286799239932615797105974710857095487342820351307477141875012176874307156016229965832589137779724973854362777629878229505500260477136108363709090010421536915488632339240756987974122598603591920306874926755600361865354330444681915154695741851960071089944015319300128574107662757054790648152751366475529121877212785489665101733755898580317984402963873738187000120737824193162011399200547424034440836239726275765901190914513013217132050988064832024783370583789324109052449717186857327239783000020791777804503930439875068662687670678802914269784817022567088069496231111407908953313902398529655056082228598715882365779469902465675715699187225655878240668599547496218159297881601061923195562143932693324644219266564617042934227893371179832389642895285401263875342640468017378925921483580111278055044254198382265567395946431803304304326865077742925818757370691726168228648841319231470626
(0.01 secs, 986,536 bytes)
*Main> fibmt 7000
59290401041683102440672829867913655667177284295570856482398561497899821008702563191682998126031426336812106306157950903693625961895457384170707696682835766197328371194280639252048666840342756165707241417947420242697378891533795188046329595393191210531240060565669691090355554675684426078893238891967744248131920159453235952521741392043432587673611875481748108922547186431244384630788896864039536935986373707241808040178029318541658974563482015180045832433560416282392506941626027765846901546580645498583385947082515709759021966156694302163967228181963857196033927978205325677091875556898095362168737467286234929361473048571929070731035278109469637105238427067353589370555252072437832137325116232609084094119857782277762930276510778198545102132608654523230820214213223413253262152536487586016127170541558616361336459796253525130197989617401215344370451870534541778633740709451069694464340846574038923007948792018770003081000900989488674868924280328705835513270541923409590927087377786662137964358712449935932999270073566350124802448041925162432545419068421227627926451096281793602407729297437577123882514541609304240451360411586459516258968726904641720306998849760845004673569691520954034222213184219616630278401443367648547274130816953541402484168718023282530489333936594435575246397995335087475094557229181966721280933610166234689048759914493059299128721036649378672598520701870210041637179272281600351183604175949714000846069179391411115592194569269933878199501
(0.04 secs, 16,843,944 bytes)
*Main> fibmt 10000
54438373113565281338734260993750380135389184554695967026247715841208582865622349017083051547938960541173822675978026317384359584751116241439174702642959169925586334117906063048089793531476108466259072759367899150677960088306597966641965824937721800381441158841042480997984696487375337180028163763317781927941101369262750979509800713596718023814710669912644214775254478587674568963808002962265133111359929762726679441400101575800043510777465935805362502461707918059226414679005690752321895868142367849593880756423483754386342639635970733756260098962462668746112041739819404875062443709868654315626847186195620146126642232711815040367018825205314845875817193533529827837800351902529239517836689467661917953884712441028463935449484614450778762529520961887597272889220768537396475869543159172434537193611263743926337313005896167248051737986306368115003088396749587102619524631352447499505204198305187168321623283859794627245919771454628218399695789223798912199431775469705216131081096559950638297261253848242007897109054754028438149611930465061866170122983288964352733750792786069444761853525144421077928045979904561298129423809156055033032338919609162236698759922782923191896688017718575555520994653320128446502371153715141749290913104897203455577507196645425232862022019506091483585223882711016708433051169942115775151255510251655931888164048344129557038825477521111577395780115868397072602565614824956460538700280331311861485399805397031555727529693399586079850381581446276433858828529535803424850845426446471681531001533180479567436396815653326152509571127480411928196022148849148284389124178520174507305538928717857923509417743383331506898239354421988805429332440371194867215543576548565499134519271098919802665184564927827827212957649240235507595558205647569365394873317659000206373126570643509709482649710038733517477713403319028105575667931789470024118803094604034362953471997461392274791549730356412633074230824051999996101549784667340458326852960388301120765629245998136251652347093963049734046445106365304163630823669242257761468288461791843224793434406079917883360676846711185597501
(0.10 secs, 50,756,424 bytes)
```
This works only because of laziness (test this in OCaml or F# to see the difference).
