# Class Test 2 Catchup

## Marking table

The exercises are defined so that it is hard to get a first-class mark.

```
  1st          - 35 marks and above.
  upper second - 30-34 marks.
  lower second - 25-29 marks.
  third        - 20-24 marks.
  fail         -  0-19 marks.
```

The module mark will be the sum of the marks on both class tests. All questions
have equal weight.

## Preparation

* The test must be completed on Jupyter Lab.
* Run `git pull` on Jupyter Lab to make sure you have the latest version of the
  course repository.
* Do __not__ modify either the file `Types.hs` or the file
  `ClassTest2Catchup-Template.hs`.
* Copy the file `ClassTest2Catchup-Template.hs` to a new file called `ClassTest2Catchup.hs`
  and write your solutions in `ClassTest2Catchup.hs`.

  __Don't change the header of this file, including the module declaration, and,
  moreover, don't change the type signature of any of the given functions for you
  to complete.__

  __If you do make changes, then we will not be able to mark your submission and
  hence it will receive zero marks!__
* Solve the exercises below in the file `ClassTest2Catchup.hs`.

The following is how you will need to run `ghci` on Jupyter for today's Class
Test.  This is important so that the monad libraries are available:

## `$ ghci ClassTest2Catchup -package mtl`

## Submission procedure

* If your submission doesn't compile or fails to pass the presubmit script on
  Jupyter Lab, it will get zero marks.
* Run the presubmit script provided to you on your submission from Jupyter by
  running `./presubmit.sh ClassTest2Catchup` in the terminal (in the same folder as
  your submission).
* This will check that your submission is in the correct format.
* If it is, submit on Canvas.
* Otherwise fix and repeat the presubmission procedure.

## Plagiarism

Plagiarism will not be tolerated. Copying and contract cheating have led to full
loss of marks, and even module or degree failure, in the past.

You will need to sign a declaration on Canvas, before submission, that you
understand the [rules](/README.md#plagiarism) and are abiding by them, in order
for your submission to qualify.

## Background material

- Each question has some **Background Material**, an **Implementation Task** and
  possibly some **Examples**.
- Read this material first, then implement the requested function.
- The corresponding type appears in the file `ClassTest2Catchup-Template.hs` (to be
  copied by you).
- Replace the default function implementation of `undefined` with your own
  function.
- This test uses the `State` and `Writer` monads. Recall that to load
  your file (i.e to test your functions in ghci), you should append
  `-package mtl` when loading the module. Specifically, you should run
  `ghci ClassTest2Catchup -package mtl` in the terminal.

## More Rules

* This is an open book test.
* You may consult your own notes, the course materials, any of the recommended
  books or [Hoogle](https://hoogle.haskell.org/).
* Feel free to write helper functions whenever convenient.
* If you do write any helper function, make sure its name does not clash with
  any of the functions in the `Types.hs` file.
* All the exercises may be solved without importing additional modules. Do not
  import any modules, as it may interfere with the marking.

## Submission Deadline

* The official submission deadline is 2pm.
* If you are provided extra time, then your submission
  deadline is that given to you by the Welfare office.

## Question 1 - Monadic Modified Fibbonnaci

### Background Material

Consider the sequence F<sub>n</sub> generated by the relation

F<sub>0</sub> = 0

F<sub>1</sub> = 1

F<sub>2</sub> = 1

F<sub>n</sub> = 7 * F<sub>n-3</sub> + 3 * F<sub>n-2</sub> 

A naive implementation can be given as follows:

```haskell
f :: Integer -> Integer
f 0 = 0
f 1 = 1
f 2 = 1
f n | n > 2 = 7 * f (n-3) + 3 * f (n-2) 
```

This naive implementation of `f` has an exponential run time and is not practical for large values of `n`.

### Implementation Task

Rewrite the above function using the state monad to improve its efficiency.

```haskell
stateF :: Integer -> State (Integer,Integer,Integer) ()
stateF = undefined

runStateF :: Integer -> Integer
runStateF n = let ((),(a,b,c)) = (runState (stateF n) (0,1,1)) in a
```
The function `runStateF n` should return the n<sup>th</sup> modified Fibonacci number 
_efficiently_, using the state monad to keep track of intermediate values. You must 
not modify `runStateF`.

This function will be tested for large values of `n`. In particular, 
`runStateF 1000` should run in well under `1` second.

### Examples

```
ghci> :set +s
ghci> runStateF 10
1621
(0.02 secs, 114,400 bytes)
ghci> runStateF 100
72051169484623192439142160965179693125
(0.00 secs, 246,968 bytes)
ghci> runStateF 1000
1809449845478782992101766453978102939586462465278514205763886856981163560626082687389237830866934038049730884860570685326202310064244177057544085907584873463622535829468420832180183703377740853580929369300559958394320736415486893499391698180027866472656542481694322169790943399557653968168484782887189600441447369699024832485224353889140566172855700364340216444174942937415132478821875
(0.01 secs, 2,007,888 bytes)
```

## Question 2 - Writing Nodes Using Writer 

### Background 

Consider the following type of ternary trees carrying data at the nodes:

```haskell
data T a = Leaf 
         | Fork a (T a) (T a) (T a)
         deriving (Eq, Show)
``` 

### Implementation Task

Write a function to perform an pre-order traversal of the tree, logging the nodes using `Just` and the leaves with `Nothing`.  By pre-order, we mean that the value at a node appears before the values of all its brances.

```haskell
writeNodes :: T a  -> Writer [Maybe a] ()
writeNodes = undefined
```
### Examples

Consider the following two ternary trees:

```haskell
t0 = Fork 4 Leaf (Fork 7 Leaf Leaf Leaf) (Fork 10 (Fork 3 Leaf Leaf Leaf) Leaf Leaf)
t1 = Fork 12 (Fork 5 Leaf Leaf (Fork 6 Leaf Leaf Leaf)) Leaf (Fork 2 Leaf (Fork 3 Leaf Leaf Leaf) Leaf)
``` 

Then we have:

```hs
ghci> snd $ runWriter $ writeNodes t0
[Just 4,Nothing,Just 7,Nothing,Nothing,Nothing,Just 10,Just 3,Nothing,Nothing,Nothing,Nothing,Nothing]
ghci> snd $ runWriter $ writeNodes t1
[Just 12,Just 5,Nothing,Nothing,Just 6,Nothing,Nothing,Nothing,Nothing,Just 2,Nothing,Just 3,Nothing,Nothing,Nothing,Nothing]
```

## Question 3 - Subtrees Determined by Ternary Addresses

### Background Material 

Referring to the type `T a` of the previous question, directions in a ternary tree can be defined by the datatype

```haskell
data Direction = L | C | R
               deriving (Eq, Show)
```
where `L` indicates the left branch, `C` the center branch, and `R` the right branch.  Addresses are then, as usual, a list of directions:
```haskell
type Address = [Direction]
```

### Implementation Task

Write a function which, given a tree and and address uses the `Maybe` type to return the subtree at the given address the address is valid, and `Nothing` otherwise.

```haskell
subtree :: T a -> Address -> Maybe (T a)
subtree = undefined 
``` 

### Example

Referring to the trees `t0` and `t1` from the previous question, we have

```hs
ghci> subtree t0 [C,L]
Just Leaf
ghci> subtree t1 [L]
Just (Fork 5 Leaf Leaf (Fork 6 Leaf Leaf Leaf))
ghci> subtree t1 [R,C]
Just (Fork 3 Leaf Leaf Leaf)
ghci> subtree t0 [L,R]
Nothing
ghci> subtree t1 [C,C,C]
Nothing
```

## Question 4 - Magic Squares

### Background Material

A magic square is an n by n grid of integers where every row, column and main diagonal add up the _same_ number. For example, the following is a magic square 
with n = 3, such that every row, column and diagonal adds up to 15.

|  |  |  |
| -- | -- | -- |
| 8 | 1 | 6 |
| 3 | 5 | 7 |
| 4 | 9 | 2 |

The two "main diagonals" in the above square are `8,5,2` and `4,5,6`.

### Implementation Task

Write a function

```haskell
isMagicSquare :: [[Int]] -> Bool
isMagicSquare = undefined
```

which takes a list of a list of integers (representing a square), and returns

1. `True` if the input represents a magic square
    * i.e every column, square and main diagonal add up to the same number,
1. `False` if the input is _not_ a representation of a magic square

You may assume that the function will receive inputs of size (n * n)
for some integer n. We will not test the function on empty magic
squares (i.e the empty list).

### Examples

```hs
ghci> isMagicSquare [[8,1,6],[3,5,7],[4,9,2]]
True
ghci> isMagicSquare [[1,2,3],[4,5,6],[7,8,9]]
False
```

## Question 5 - Finding Nulls in Json Data

Recall the type of [Json](https://en.wikipedia.org/wiki/JSON) data defined in the [lecture](https://git.cs.bham.ac.uk/fp/learning-2022/-/blob/main/files/LectureNotes/LiveCoding/lecture7.hs):

```haskell
data Json = JNull
          | JStr String
          | JNum Float
          | JBool Bool
          | JArr [Json]
          | JObj [(String, Json)]
		  deriving (Eq, Show)
``` 

### Implementation Task

Count the number of `JNull`s using the state monad.

```haskell
countNulls :: Json -> State Integer () 
countNulls = undefined
```

### Examples

Consider the following bit of Json data:

```haskell
json = JObj [ ("firstName" , JStr "John")
            , ("lastName" , JStr "Smith")
            , ("spouse" , JNull)
            , ("address" , JObj [ ("street" , JStr "21 2nd St.")
                                , ("city" , JStr "Denver")
                                , ("apartment no.", JNull)
                                ])
            ]
```

Our program gives:

```hs
ghci> runState (countNulls json) 0
((),2)
```

