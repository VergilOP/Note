- [Note of Python](#note-of-python)
  - [第1章 基础知识](#第1章-基础知识)
    - [1.1 交互式解释器](#11-交互式解释器)
    - [1.2 算法是什么](#12-算法是什么)
    - [1.3 数和表达式](#13-数和表达式)
    - [1.4 变量](#14-变量)
    - [1.5 语句](#15-语句)
    - [1.6 获取用户输入](#16-获取用户输入)
    - [1.7 函数](#17-函数)
    - [1.8 模块](#18-模块)
      - [1.8.1 cmath和复数](#181-cmath和复数)
      - [1.8.2 回到未来](#182-回到未来)
    - [1.9 保存并执行程序](#19-保存并执行程序)
      - [1.9.1 从命令提示符运行Python脚本](#191-从命令提示符运行python脚本)
      - [1.9.2 让脚本像普通程序一样](#192-让脚本像普通程序一样)
      - [1.9.3 注释](#193-注释)
    - [1.10 字符串](#110-字符串)
      - [1.10.1 单引号字符串以及对引号转义](#1101-单引号字符串以及对引号转义)
      - [1.10.2 拼接字符串](#1102-拼接字符串)
      - [1.10.3 字符串表示str和repr](#1103-字符串表示str和repr)
      - [1.10.4 长字符串、原始字符串和字节](#1104-长字符串原始字符串和字节)
    - [1.11 小结](#111-小结)
      - [1.11.1 本章介绍的新函数](#1111-本章介绍的新函数)
      - [1.11.2 预告](#1112-预告)
  - [第2章 列表与元组](#第2章-列表与元组)
    - [2.1 序列概述](#21-序列概述)
    - [2.2 通用的序列操作](#22-通用的序列操作)
      - [2.2.1 索引](#221-索引)
      - [2.2.2 切片](#222-切片)
      - [2.2.3 序列相加](#223-序列相加)
      - [2.2.4 乘法](#224-乘法)
      - [2.2.5 成员资格](#225-成员资格)
    - [2.3 列表: Python的主力](#23-列表-python的主力)
      - [2.3.1 函数list](#231-函数list)
      - [2.3.2 基本的列表操作](#232-基本的列表操作)
      - [2.3.3 列表方法](#233-列表方法)
    - [2.4 元组：不可修改的序列](#24-元组不可修改的序列)
    - [2.5 小结](#25-小结)
      - [2.5.1 本章介绍的新函数](#251-本章介绍的新函数)
      - [2.5.2 预告](#252-预告)
  - [第3章 使用字符串](#第3章-使用字符串)
    - [3.1 字符串基本操作](#31-字符串基本操作)
    - [3.2 设置字符串的格式: 精简版](#32-设置字符串的格式-精简版)
    - [3.3 设置字符串的格式: 完整版](#33-设置字符串的格式-完整版)
      - [3.3.1 替换字段名](#331-替换字段名)
      - [3.3.2 基本转换](#332-基本转换)
      - [3.3.3 宽度、精度和千位分隔符](#333-宽度精度和千位分隔符)
      - [3.3.4 符号、对齐和用 0 填充](#334-符号对齐和用-0-填充)
    - [3.4 字符串方法](#34-字符串方法)
      - [3.4.1 center](#341-center)
      - [3.4.2 find](#342-find)
      - [3.4.3 join](#343-join)
      - [3.4.4 lower](#344-lower)
      - [3.4.5 replace](#345-replace)
      - [3.4.6 split](#346-split)
      - [3.4.7 strip](#347-strip)
      - [3.4.8 translate](#348-translate)
      - [3.4.9 判断字符串是否满足特定的条件](#349-判断字符串是否满足特定的条件)
    - [3.5 小结](#35-小结)
      - [3.5.1 本章介绍的新函数](#351-本章介绍的新函数)
  - [第4章 当索引行不通时](#第4章-当索引行不通时)
    - [4.1 字典的用途](#41-字典的用途)
    - [4.2 创建和使用字典](#42-创建和使用字典)
      - [4.2.1 函数 dict](#421-函数-dict)
      - [4.2.2 基本的字典操作](#422-基本的字典操作)
      - [4.2.3 将字符串格式设置功能用于字典](#423-将字符串格式设置功能用于字典)
      - [4.2.4 字典方法](#424-字典方法)
    - [4.3 小结](#43-小结)
      - [4.3.1 本章介绍的新函数](#431-本章介绍的新函数)
  - [第5章 条件、循环及其他语句](#第5章-条件循环及其他语句)
    - [5.1 再谈 print 和 import](#51-再谈-print-和-import)
      - [5.1.1 打印多个参数](#511-打印多个参数)
      - [5.1.2 导入时重命名](#512-导入时重命名)
    - [5.2 赋值魔法](#52-赋值魔法)
      - [5.2.1 序列解包](#521-序列解包)
      - [5.2.2 链式赋值](#522-链式赋值)
      - [5.2.3 增强赋值](#523-增强赋值)
    - [5.3 代码块：缩进的乐趣](#53-代码块缩进的乐趣)
    - [5.4 条件和条件语句](#54-条件和条件语句)
      - [5.4.1 这正是布尔值的用武之地](#541-这正是布尔值的用武之地)
      - [5.4.2 有条件地执行和 if 语句](#542-有条件地执行和-if-语句)
      - [5.4.3 else 子句](#543-else-子句)
      - [5.4.4 elif 子句](#544-elif-子句)
      - [5.4.5 代码块嵌套](#545-代码块嵌套)
      - [5.4.6 更复杂的条件](#546-更复杂的条件)
    - [5.5 循环](#55-循环)
      - [5.5.1 while 循环](#551-while-循环)
      - [5.5.2 for 循环](#552-for-循环)
      - [5.5.3 迭代字典](#553-迭代字典)
      - [5.5.4 一些迭代工具](#554-一些迭代工具)
      - [5.5.5 跳出循环](#555-跳出循环)
      - [5.5.6 循环中的 else 子句](#556-循环中的-else-子句)
    - [5.6 简单推导](#56-简单推导)
    - [5.7 三人行](#57-三人行)
      - [5.7.1 什么都不做](#571-什么都不做)
      - [5.7.2 使用 del 删除](#572-使用-del-删除)
      - [5.7.3 使用 exec 和 eval 执行字符串及计算其结果](#573-使用-exec-和-eval-执行字符串及计算其结果)
    - [5.8 小结](#58-小结)
      - [5.8.1 本章介绍的新函数](#581-本章介绍的新函数)
  - [第6章 抽象](#第6章-抽象)
    - [6.1 懒惰是一种美德](#61-懒惰是一种美德)
    - [6.2 抽象和结构](#62-抽象和结构)
    - [6.3 自定义函数](#63-自定义函数)
      - [6.3.1 给函数编写文档](#631-给函数编写文档)
      - [6.3.2 其实并不是函数的函数](#632-其实并不是函数的函数)
    - [6.4 参数魔法](#64-参数魔法)
      - [6.4.1 值从哪里来](#641-值从哪里来)
      - [6.4.2 我能修改参数吗](#642-我能修改参数吗)
      - [6.4.3 关键字参数和默认值](#643-关键字参数和默认值)
      - [6.4.4 收集参数](#644-收集参数)
      - [6.4.5 分配参数](#645-分配参数)
      - [6.4.6 练习使用参数](#646-练习使用参数)
    - [6.5 作用域](#65-作用域)
    - [6.6 递归](#66-递归)
      - [6.6.1 两个经典案例：阶乘和幂](#661-两个经典案例阶乘和幂)
      - [6.6.2 另一个经典案例：二分查找](#662-另一个经典案例二分查找)
    - [6.7 小结](#67-小结)
    - [6.7.1 本章介绍的新函数](#671-本章介绍的新函数)
  - [第7章 再谈抽象](#第7章-再谈抽象)
    - [7.1 对象魔法](#71-对象魔法)
      - [7.1.1 多态](#711-多态)
      - [7.1.2 多态和方法](#712-多态和方法)
      - [7.1.3 封装](#713-封装)
      - [7.1.4 继承](#714-继承)
    - [7.2 类](#72-类)
      - [7.2.1 类到底是什么](#721-类到底是什么)
      - [7.2.2 创建自定义类](#722-创建自定义类)
      - [7.2.3 属性、函数和方法](#723-属性函数和方法)
      - [7.2.4 再谈隐藏](#724-再谈隐藏)
      - [7.2.5 类的命名空间](#725-类的命名空间)
      - [7.2.6 指定超类](#726-指定超类)
      - [7.2.7 深入探讨继承](#727-深入探讨继承)
      - [7.2.8 多个超类](#728-多个超类)
      - [7.2.9 接口和内省](#729-接口和内省)
      - [7.2.10 抽象基类](#7210-抽象基类)
    - [7.3 关于面向对象设计的一些思考](#73-关于面向对象设计的一些思考)
    - [7.4 小结](#74-小结)
      - [7.4.1 本章介绍的新函数](#741-本章介绍的新函数)
  - [第8章 异常](#第8章-异常)
    - [8.1 异常是什么](#81-异常是什么)
    - [8.2 让事情沿你指定的轨道出错](#82-让事情沿你指定的轨道出错)
      - [8.2.1 raise 语句](#821-raise-语句)
      - [8.2.2 自定义的异常类](#822-自定义的异常类)
    - [8.3 捕获异常](#83-捕获异常)
      - [8.3.1 不用提供参数](#831-不用提供参数)
      - [8.3.2 多个 except 子句](#832-多个-except-子句)
      - [8.3.3 一箭双雕](#833-一箭双雕)
      - [8.3.4 捕获对象](#834-捕获对象)
      - [8.3.5 一网打尽](#835-一网打尽)
      - [8.3.6 万事大吉时](#836-万事大吉时)
      - [8.3.7 最后](#837-最后)
    - [8.4 异常和函数](#84-异常和函数)
    - [8.5 异常之禅](#85-异常之禅)
    - [8.6 不那么异常的情况](#86-不那么异常的情况)
    - [8.7 小结](#87-小结)
      - [8.7.1 本章介绍的新函数](#871-本章介绍的新函数)
  - [第9章 魔法方法、特性和迭代器](#第9章-魔法方法特性和迭代器)
    - [9.1 如果你使用的不是 Python 3(略)](#91-如果你使用的不是-python-3略)
    - [9.2 构造函数](#92-构造函数)
      - [9.2.1 重写普通方法和特殊的构造函数](#921-重写普通方法和特殊的构造函数)
      - [9.2.2 调用未关联的超类构造函数](#922-调用未关联的超类构造函数)
      - [9.2.3 使用函数 super](#923-使用函数-super)
    - [9.3 元素访问](#93-元素访问)
      - [9.3.1 基本的序列和映射协议](#931-基本的序列和映射协议)
      - [9.3.2 从 list、dict 和 str 派生](#932-从-listdict-和-str-派生)
    - [9.4 其他魔法方法](#94-其他魔法方法)
    - [9.5 特性](#95-特性)
      - [9.5.1 函数 property](#951-函数-property)
      - [9.5.2 静态方法和类方法](#952-静态方法和类方法)
      - [9.5.3 \_\_getattr\_\_、__setattr__等方法](#953-__getattr____setattr__等方法)
    - [9.6 迭代器](#96-迭代器)
      - [9.6.1 迭代器协议](#961-迭代器协议)
      - [9.6.2 从迭代器创建序列](#962-从迭代器创建序列)
    - [9.7 生成器](#97-生成器)
      - [9.7.1 创建生成器](#971-创建生成器)
      - [9.7.2 递归式生成器](#972-递归式生成器)
      - [9.7.3 通用生成器](#973-通用生成器)
      - [9.7.4 生成器的方法](#974-生成器的方法)
      - [9.7.5 模拟生成器](#975-模拟生成器)
    - [9.8 八皇后问题](#98-八皇后问题)
      - [9.8.1 生成器的回溯](#981-生成器的回溯)
      - [9.8.2 问题](#982-问题)
      - [9.8.3 状态表示](#983-状态表示)
      - [9.8.4 检测冲突](#984-检测冲突)
      - [9.8.5 基线条件](#985-基线条件)
      - [9.8.6 递归条件](#986-递归条件)
      - [9.8.7 扫尾工作](#987-扫尾工作)
    - [9.9 小结](#99-小结)
      - [9.9.1 本章介绍的新函数](#991-本章介绍的新函数)
  - [第10章 开箱即用](#第10章-开箱即用)
    - [10.1 模块](#101-模块)
      - [10.1.1 模块就是程序](#1011-模块就是程序)
      - [10.1.2 模块是用来下定义的](#1012-模块是用来下定义的)
      - [10.1.3 让模块可用](#1013-让模块可用)
      - [10.1.4 包](#1014-包)
    - [10.2 探索模块](#102-探索模块)
      - [10.2.1 模块包含什么](#1021-模块包含什么)
      - [10.2.2 使用 help 获取帮助](#1022-使用-help-获取帮助)
      - [10.2.3 文档](#1023-文档)
      - [10.2.4 使用源代码](#1024-使用源代码)
    - [10.3 标准库：一些深受欢迎的模块](#103-标准库一些深受欢迎的模块)
      - [10.3.1 sys](#1031-sys)
      - [10.3.2 os](#1032-os)
      - [10.3.3 fileinput](#1033-fileinput)
      - [10.3.4 集合、堆和双端队列](#1034-集合堆和双端队列)
      - [10.3.5 time](#1035-time)
      - [10.3.6 random](#1036-random)
      - [10.3.7 shelve 和 json](#1037-shelve-和-json)
      - [10.3.8 re](#1038-re)
      - [10.3.9 其他有趣的标准模块](#1039-其他有趣的标准模块)
    - [10.4 小结](#104-小结)
      - [10.4.1 本章介绍的新函数](#1041-本章介绍的新函数)
  - [第11章 文件](#第11章-文件)
    - [11.1 打开文件](#111-打开文件)

# Note of Python

---

## 第1章 基础知识

### 1.1 交互式解释器

- 无需分号,如果愿意也可以加上分号,但不会有任何影响(除非后面还有其他的代码)

### 1.2 算法是什么

- 类似与流程或者菜谱,尽可能地详尽地描述如何完成某项任务

### 1.3 数和表达式

```
>>> 1 / 2
0.5
```

结果为浮点数(float)

```
>>> 1 / 1
1.0
```

尽管是1但是仍是浮点数

- 如果想要舍弃小数部分

```
>>> 1 // 2
0
```

- 如果想要取余

```
>>> 1 % 2
1
```

x % y 等价于 x - ((x // y) * y)

- 负数的取余 - 特殊

```
>>> 10 % 3
1

>>> 10 % -3
-2

>>> -10 % 3
2

>>> -10 % -3
-1
```

这些结果是因为等价的式子 x - ((x // y) * y)

- 负数的整除 - 特殊

```
>>> 10 // 3
3

>>> 10 // -3
-4

>>> -10 // 3
-4

>>> -10 // -3
3
```

总结: 结果为负数的情况下,圆整后将离0更远. 这意味着对于,-10 // 3
将向下圆整到-4,而不是向上圆整到 -3

- 乘方运算符

```
>>> 2 ** 3
8
>>> -3 ** 2
-9

>>> (-3) ** 2
9
```

注意乘方的优先级比求负高

***十六进制八进制和二进制***

```
> > > 0xAF
175
### 十六进制 Hex

>>>0o10
8
### 八进制 Octal

>>> 0b1011010010
722
### 二进制 Binary
```

这些算法都以0开头

### 1.4 变量

**变量**时表示(或*指向*)特定值的名称 #(指向地址)

```
>>> x = 3
```

**赋值**

> 在Python中,名称(标识符)只能由字母,数字和下划线(_)构成,且不能以数字打头.
> 因此Plan9是合法的,而9Plan不是

### 1.5 语句

```
>>> 2 * 2
4

>>> print(2 * 2)
4
```

### 1.6 获取用户输入

```
>>> input("The meaning of life: ")
The meaning of life: 42
'42'
```

执行第一行, 打印字符"The meaning of life: "提示用户输入相应信息 #
这里的'42'是字符串

```
>>> x = input("x: ") 
x: 34 

>>> y = input("y: ") 
y: 42 

>>> print(int(x) * int(y)) 
1428
```

### 1.7 函数

幂运算的函数pow()

```
>>> 2 ** 3 
8 

>>> pow(2, 3) 
8
```

类似于pow等标准函数为**内置函数**

**调用**函数pow(),提供**实参**2,3

- 绝对值函数与圆整函数

```
>>> abs(-10) 
10 

>>> 2 // 3 
0 

>>> round(2 / 3) 
1.0
```

向最接近圆整round,向下圆整floor

### 1.8 模块

```
>>> import math 
>>> math.floor(32.9) 
32
```

我们使用import导入模块，再以module.function的方式使用模块中的函数

```
>>> math.ceil(32.3) 
33 

>>> math.ceil(32) 
32
```

向上圆整

```
>>> from math import sqrt 
>>> sqrt(9) 
3.0
```

通过使用命令import的变种from module import
function，可在调用函数时不指定模块前缀。

#### 1.8.1 cmath和复数

- sqrt被提供负数时

```
>>> from math import sqrt 
>>> sqrt(-1) 
Traceback (most recent call last): 
...
ValueError: math domain error
```

某些平台显示

```
>>> sqrt(-1) 
nan
```

> nan具有特殊含义，指的是“非数值”（not a number）

- 导入处理**复数**的模块

```
>>> import cmath 
>>> cmath.sqrt(-1) 
1j
```

注意到这里没有使用from ... import
...。如果使用了这种import命令，将无法使用常规函数sqrt

```
>>> (1 + 3j) * (9 + 4j) 
(-3 + 31j)
```

> Python没有专门表示虚数的类型，而将虚数视为实部为零的复数

#### 1.8.2 回到未来

跳过SKIP

### 1.9 保存并执行程序

跳过SKIP

#### 1.9.1 从命令提示符运行Python脚本

```
C:\>python hello.py
```

#### 1.9.2 让脚本像普通程序一样

跳过SKIP

#### 1.9.3 注释

在代码中，井号(#)后面到行尾的所有内容都将被忽略

```
# 打印圆的周长：
print(2 * pi * radius)
```

注释让程序更容易理解

### 1.10 字符串

```
print("Hello, world!")
```

"Hello, world!"是**字符串**

#### 1.10.1 单引号字符串以及对引号转义

单引号与双引号完全相同 但在特殊情况下有帮助

```
>>> "Let's go!" 
"Let's go!" 

>>> '"Hello, world!" she said' 
'"Hello, world!" she said'
```

使用反斜杠（\）对引号进行转义

```
>>> 'Let\'s go!' 
"Let's go!"
```

#### 1.10.2 拼接字符串

```
>>> "Hello, " + "world!" 
'Hello, world!' 
>>> x = "Hello, " 
>>> y = "world!" 
>>> x + y 
'Hello, world!'
```

#### 1.10.3 字符串表示str和repr

换行符\n

```
>>> "Hello,\nworld!" 
'Hello,\nworld!' 

>>> print("Hello,\nworld!") 
Hello, 
world!
```

repr会获得值的合法Python表达式表示

```
>>> print(repr("Hello,\nworld!")) 
'Hello,\nworld!' 
>>> print(str("Hello,\nworld!")) 
Hello, 
world!
```

#### 1.10.4 长字符串、原始字符串和字节

1. 长字符串

   要表示很长的字符串（跨越多行的字符串），可使用三引号（而不是普通引号）。

   ```
   print('''This is a very long string. It continues here. 
   And it's not over yet. "Hello, world!" 
   Still here.''')
   ```

   还可使用三个双引号

   > 常规字符串也可横跨多行。只要在行尾加上反斜杠，反斜杠和换行符将被转义，即被忽略。例如，如果编写如下代码：
   > print("Hello, 
   > world!")
   > 它将打印Hello, world!。这种处理手法也适用于表达式和语句
   >
2. 原始字符串

   字符串中包含换行符

   ```
   >>> print('Hello,\nworld!') 
   Hello, 
   world!
   ```

   对反斜杠本身进行转义

   ```
   >>> print('C:\\nowhere') 
   C:\nowhere
   ```

   运用原始字符串r

   ```
   >>> print(r'C:\nowhere') 
   C:\nowhere 

   >>> print(r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz') 
   C:\Program Files\fnord\foo\bar\baz\frozz\bozz
   ```

   原始字符串的最后一个字符不能是反斜杠

   ```
   >>> print(r"This is illegal\") 
   SyntaxError: EOL while scanning string literal

   >>> print(r'C:\Program Files\foo\bar' '\\') 
   C:\Program Files\foo\bar\
   ```
3. Unicode、bytes和bytearray

   ```
   >>> "\u00C6" 
   'Æ' 

   >>> "\U0001F60A" 
   '☺ '

   >>> "This is a cat: \N{Cat}" 
   'This is a cat: '
   ```

   使用ASCII、UTF-8和UTF-32编码将字符串转换为bytes

   ```
   >>> "Hello, world!".encode("ASCII") 
   b'Hello, world!' 

   >>> "Hello, world!".encode("UTF-8") 
   b'Hello, world!' 

   >>> "Hello, world!".encode("UTF-32") 
   b'\xff\xfe\x00\x00H\x00\x00\x00e\x00\x00\x00l\x00\x00\x00l\x00\x00\x00o\x00\x00\x00,\x00\ 
   x00\x00 \x00\x00\x00w\x00\x00\x00o\x00\x00\x00r\x00\x00\x00l\x00\x00\x00d\x00\x00\x00!\x00\ 
   x00\x00'
   ```

   ```
   >>> len("How long is this?".encode("UTF-8")) 
   17 

   >>> len("How long is this?".encode("UTF-32")) 
   72
   ```

   只要字符串包含较怪异的字符，ASCII和UTF-8之间的差别便显现出来了

   ```
   >>> "Hællå, wørld!".encode("ASCII") 
   Traceback (most recent call last): 
    ... 
   UnicodeEncodeError: 'ascii' codec can't encode character '\xe6' in position 1: ordinal not 
   in range(128)
   ```

   可向encode提供另一个实参，告诉它如何处理错误

   ```
   >>> "Hællå, wørld!".encode("ASCII", "ignore") 
   b'Hll, wrld!' 

   >>> "Hællå, wørld!".encode("ASCII", "replace") 
   b'H?ll?, w?rld!' 

   >>> "Hællå, wørld!".encode("ASCII", "backslashreplace") 
   b'H\\xe6ll\\xe5, w\\xf8rld!' 

   >>> "Hællå, wørld!".encode("ASCII", "xmlcharrefreplace") 
   b'Hællå, wørld!'
   ```

   几乎在所有情况下，都最好使用UTF-8。事实上，它也是默认使用的编码

   ```
   >>> "Hællå, wørld!".encode() 
   b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!'

   >>> b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!'.decode() 
   'Hællå, wørld!'
   ```

   可不使用方法encode和decode，而直接创建bytes和str（即字符串）对象

   ```
   >>> bytes("Hællå, wørld!", encoding="utf-8") 
   b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!' 

   >>> str(b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!', encoding="utf-8") 
   'Hællå, wørld!'
   ```

   编码和解码的最重要用途之一是，将文本存储到磁盘文件中

   bytearray是可修改的字符串

   ```
   >>> x = bytearray(b"Hello!") 
   >>> x[1] = ord(b"u") 
   >>> x 
   bytearray(b'Hullo!')
   ```

### 1.11 小结

- **算法**：算法犹如菜谱，告诉你如何完成特定的任务。从本质上说，编写计算机程序就是
  使用计算机能够理解的语言（如Python）描述一种算法。这种对机器友好的描述被称为程
  序，主要由表达式和语句组成。
- **表达式**：表达式为程序的一部分，结果为一个值。例如，2 + 2就是一个表达式，结果为
  4。简单表达式是使用运算符（如+或%）和函数（如pow）将字面值（如2或"Hello"）组
  合起来得到的。通过组合简单的表达式，可创建复杂的表达式，如(2 + 2) *(3 - 1)。表
  达式还可能包含变量。
- **变量**：变量是表示值的名称。通过赋值，可将新值赋给变量，如x = 2。赋值是一种语句。
- **语句**：语句是让计算机执行特定操作的指示。这种操作可能是修改变量（通过赋值）、将
  信息打印到屏幕上（如print("Hello, world!")）、导入模块或执行众多其他任务。
- **函数**：Python函数类似于数学函数，它们可能接受参数，并返回结果（在第6章学习编写
  自定义函数时，你将发现函数实际上可以在返回前做很多事情）。
- **模块**：模块是扩展，可通过导入它们来扩展Python的功能。例如，模块math包含多个很有
  用的函数。
- **程序**：你通过练习学习了如何编写、保存和运行Python程序。
- **字符串**：字符串非常简单。它们其实就是一段文本，其中的字符是用Unicode码点表示的。
  然而，对于字符串，需要学习的知识有很多。本章介绍了很多表示字符串的方式，第3章
  将介绍众多字符串用法。

#### 1.11.1 本章介绍的新函数


| 函 数                               | 描 述                                                             |
| :---------------------------------- | :---------------------------------------------------------------- |
| abs(number)                         | 返回指定数的绝对值                                                |
| bytes(string, encoding\[, errors\]) | 对指定的字符串进行编码，并以指定的方式处理错误                    |
| cmath.sqrt(number)                  | 返回平方根；可用于负数                                            |
| float(object)                       | 将字符串或数字转换为浮点数                                        |
| help(\[object\])                    | 提供交互式帮助                                                    |
| input(prompt)                       | 以字符串的方式获取用户输入                                        |
| int(object)                         | 将字符串或数转换为整数                                            |
| math.ceil(number)                   | 以浮点数的方式返回向上圆整的结果                                  |
| math.floor(number)                  | 以浮点数的方式返回向下圆整的结果                                  |
| math.sqrt(number)                   | 返回平方根；不能用于负数                                          |
| pow(x, y\[, z\])                    | 返回x的y次方对z求模的结果                                         |
| print(object, ...)                  | 将提供的实参打印出来，并用空格分隔                                |
| repr(object)                        | 返回指定值的字符串表示                                            |
| round(number\[, ndigits\])          | 四舍五入为指定的精度，正好为5时舍入到偶数                         |
| str(object)                         | 将指定的值转换为字符串。用于转换bytes时，可指定编码和错误处理方式 |

#### 1.11.2 预告

跳过SKIP

## 第2章 列表与元组

### 2.1 序列概述

列表和元组的主要不同在于，列表是可以修改的，而元组不可以

这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形

```
>>> edward = ['Edward Gumby', 42]
>>> john = ['John Smith', 50] 
>>> database = [edward, john] 
>>> database 
[['Edward Gumby', 42], ['John Smith', 50]]
```

> Python支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。

### 2.2 通用的序列操作

有几种操作适用于所有序列，包括索引、切片、相加、相乘和成员资格检查

#### 2.2.1 索引

```
>>> greeting = 'Hello' 
>>> greeting[0] 
'H'
```

当你使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此1是最后一个元素的位置

```
>>> greeting[-1] 
'o'
```

如果函数调用返回一个序列，可直接对其执行索引操作

```
>>> fourth = input('Year: ')[3] 
Year: 2005 

>>> fourth 
'5'
```

#### 2.2.2 切片

使用切片（slicing）来访问特定范围内的元素

```
>>> tag = '<a href="http://www.python.org">Python web site</a>' 
>>> tag[9:30] 
'http://www.python.org' 

>>> tag[32:-4] 
'Python web site'
```

1.绝妙的简写

    ```
    >>> numbers[-3:-1] 
    [8, 9]

    >>> numbers[-3:0] 
    []

    >>> numbers[-3:] 
    [8, 9, 10]

    >>> numbers[:3] 
    [1, 2, 3]

    >>> numbers[:] 
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    ```

2. 更大的步长

    在普通切片中，步长为1

    ```
    >>> numbers[0:10:1] 
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    >>> numbers[0:10:2] 
    [1, 3, 5, 7, 9] 

    >>> numbers[3:6:3] 
    [4]
    ```

    ```
    >>> numbers[::4] 
    [1, 5, 9]
    ```

    负数步长

    ```
    >>> numbers[8:3:-1] 
    [9, 8, 7, 6, 5] 

    >>> numbers[10:0:-2] 
    [10, 8, 6, 4, 2] 

    >>> numbers[0:10:-2] 
    [] 

    >>> numbers[::-2] 
    [10, 8, 6, 4, 2]

    >>> numbers[5::-2] 
    [6, 4, 2]
    
    >>> numbers[:5:-2] 
    [10, 8]
    ```

#### 2.2.3 序列相加

```
>>> [1, 2, 3] + [4, 5, 6] 
[1, 2, 3, 4, 5, 6] 

>>> 'Hello,' + 'world!' 
'Hello, world!' 

>>> [1, 2, 3] + 'world!' 
Traceback (innermost last): 
 File "<pyshell>", line 1, in ? 
 [1, 2, 3] + 'world!' 
TypeError: can only concatenate list (not "string") to list
```

#### 2.2.4 乘法

```
>>> 'python' * 5 
'pythonpythonpythonpythonpython' 

>>> [42] * 10 
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
```

要将列表的长度初始化为10

```
>>> sequence = [None] * 10 
>>> sequence 
[None, None, None, None, None, None, None, None, None, None]
```

#### 2.2.5 成员资格

```
>>> permissions = 'rw' 
>>> 'w' in permissions 
True 

>>> 'x' in permissions 
False 

>>> users = ['mlh', 'foo', 'bar'] 
>>> input('Enter your user name: ') in users 
Enter your user name: mlh 
True 

>>> subject = '$$$ Get rich now!!! $$$' 
>>> '$$$' in subject 
True
```

长度、最小值和最大值

```
>>> numbers = [100, 34, 678] 
>>> len(numbers) 
3 

>>> max(numbers) 
678 

>>> min(numbers)
34 

>>> max(2, 3) 
3 

>>> min(9, 3, 2, 5) 
2
```

### 2.3 列表: Python的主力

SKIP跳过

#### 2.3.1 函数list

```
>>> list('Hello') 
['H', 'e', 'l', 'l', 'o']
```

#### 2.3.2 基本的列表操作

1. 修改列表: 给元素赋值

    ```
    >>> x = [1, 1, 1] 
    >>> x[1] = 2 
    >>> x 
    [1, 2, 1]
    ```

2. 删除元素

    ```
    >>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl'] 
    >>> del names[2] 
    >>> names 
    ['Alice', 'Beth', 'Dee-Dee', 'Earl']
    ```

3. 给切片赋值

    ```
    >>> name = list('Perl') 
    >>> name 
    ['P', 'e', 'r', 'l'] 

    >>> name[2:] = list('ar') 
    >>> name 
    ['P', 'e', 'a', 'r']

    >>> name = list('Perl') 
    >>> name[1:] = list('ython') 
    >>> name 
    ['P', 'y', 't', 'h', 'o', 'n']
    ```

    切片赋值还可在不替换原有元素的情况下插入新元素。

    ```
    >>> numbers = [1, 5] 
    >>> numbers[1:1] = [2, 3, 4] 
    >>> numbers 
    [1, 2, 3, 4, 5]
    ```

    采取相反的措施来删除切片

    ```
    >>> numbers 
    [1, 2, 3, 4, 5] 

    >>> numbers[1:4] = [] 
    >>> numbers 
    [1, 5]
    ```

#### 2.3.3 列表方法

1. append

    方法append用于将一个对象附加到列表末尾

    ```
    >>> lst = [1, 2, 3] 
    >>> lst.append(4) 
    >>> lst 
    [1, 2, 3, 4]
    ```

2. clear

    方法clear就地清空列表的内容

    ```
    >>> lst = [1, 2, 3] 
    >>> lst.clear() 
    >>> lst 
    []
    ```

3. copy

    方法 copy 复制列表. 常规复制只是将另一个名称关联到列表

    ```
    >>> a = [1, 2, 3] 
    >>> b = a 
    >>> b[1] = 4 
    >>> a 
    [1, 4, 3]
    ```

    ```
    >>> a = [1, 2, 3] 
    >>> b = a.copy() 
    >>> b[1] = 4 
    >>> a 
    [1, 2, 3]
    ```

4. count

    方法count计算指定的元素在列表中出现了多少次
    
    ```
    >>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to') 
    2 
    
    >>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]] 
    >>> x.count(1) 
    2 
    
    >>> x.count([1, 2]) 
    1
    ```

5. extend

    方法extend让你能够同时将多个值附加到列表末尾

    ```
    >>> a = [1, 2, 3] 
    >>> b = [4, 5, 6] 
    >>> a.extend(b) 
    >>> a 
    [1, 2, 3, 4, 5, 6]
    ```

    这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列（这里是a）。
    在常规拼接中，情况是返回一个全新的序列。

    ```
    >>> a = [1, 2, 3] 
    >>> b = [4, 5, 6] 
    >>> a + b 
    [1, 2, 3, 4, 5, 6] 

    >>> a 
    [1, 2, 3]
    ```

    要获得与extend相同的效果

    ```
    >>> a = [1, 2, 3] 
    >>> b = [4, 5, 6] 
    >>> a[len(a):] = b 
    >>> a 
    [1, 2, 3, 4, 5, 6]
    ```

    虽然可行，但*可读性不是很高*

6. index

    方法index在列表中查找指定值第一次出现的索引

    ```
    >>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni'] 
    >>> knights.index('who') 
    4 

    >>> knights.index('herring') 
    Traceback (innermost last): 
     File "<pyshell>", line 1, in ? 
     knights.index('herring') 
    ValueError: list.index(x): x not in list
    ```

    然而，搜索'herring'时引发了异常，因为根本就没有找到这个单词

7. insert

    方法insert用于将一个对象插入列表。

    ```
    >>> numbers = [1, 2, 3, 5, 6, 7] 
    >>> numbers.insert(3, 'four') 
    >>> numbers 
    [1, 2, 3, 'four', 5, 6, 7]
    ```

    与extend一样，也可使用切片赋值来获得与insert一样的效果

    ```
    >>> numbers = [1, 2, 3, 5, 6, 7] 
    >>> numbers[3:3] = ['four'] 
    >>> numbers 
    [1, 2, 3, 'four', 5, 6, 7]
    ```

    虽然可行，但*可读性不是很高*

8. pop

    方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素

    ```
    >>> x = [1, 2, 3] 
    >>> x.pop() 
    3 

    >>> x 
    [1, 2] 

    >>> x.pop(0) 
    1 

    >>> x 
    [2]
    ```

    > pop是唯一既修改列表又返回一个非None值的列表方法。

    使用pop可实现一种常见的数据结构——栈（stack）后进先出（LIFO） - Python没有提供push，但可使用append来替代先进先出（FIFO） - 可使用insert(0, ...)代替append

9. remove

    方法remove用于删除第一个为指定值的元素

    ```
    >>> x = ['to', 'be', 'or', 'not', 'to', 'be'] 
    >>> x.remove('be') 
    >>> x 
    ['to', 'or', 'not', 'to', 'be'] 

    >>> x.remove('bee') 
    Traceback (innermost last): 
     File "<pyshell>", line 1, in ? 
     x.remove('bee') 
    ValueError: list.remove(x): x not in list
    ```

    不同于pop的是，它修改列表，但不返回任何值

10. reverse

    方法reverse按相反的顺序排列列表中的元素

    ```
    >>> x = [1, 2, 3] 
    >>> x.reverse() 
    >>> x 
    [3, 2, 1]
    ```

    注意到reverse修改列表，但不返回任何值

11. sort

    方法sort用于对列表就地排序

    ```
    >>> x = [4, 6, 2, 1, 7, 9] 
    >>> x.sort() 
    >>> x 
    [1, 2, 4, 6, 7, 9]
    ```

    ```
    >>> x = [4, 6, 2, 1, 7, 9] 
    >>> y = x.sort() # Don't do this! 
    >>> print(y) 
    None
    ```

    sort修改x且不返回任何值

    正确方法

    ```
    >>> x = [4, 6, 2, 1, 7, 9] 
    >>> y = x.copy() 
    >>> y.sort() 
    >>> x 
    [4, 6, 2, 1, 7, 9] 

    >>> y 
    [1, 2, 4, 6, 7, 9]
    ```

    为获取排序后的列表的副本，另一种方式是使用函数sorted

    ```
    >>> x = [4, 6, 2, 1, 7, 9] 
    >>> y = sorted(x) 
    >>> x 
    [4, 6, 2, 1, 7, 9] 

    >>> y 
    [1, 2, 4, 6, 7, 9]
    ```

    这个函数可用于任何序列，但总是返回一个列表

    ```
    >>> sorted('Python') 
    ['P', 'h', 'n', 'o', 't', 'y']
    ```

12. 高级排序

    要根据长度对元素进行排序，可将参数key设置为函数len
    
    ```
    >>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] 
    >>> x.sort(key=len) 
    >>> x 
    ['add', 'acme', 'aerate', 'abalone', 'aardvark']
    ```
    
    对于另一个关键字参数reverse，只需将其指定为一个真值，以指出是否要按相反的顺序对列表进行排序
    
    ```
    >>> x = [4, 6, 2, 1, 7, 9] 
    >>> x.sort(reverse=True) 
    >>> x 
    [9, 7, 6, 4, 2, 1]
    ```

### 2.4 元组：不可修改的序列

元组也是序列，唯一的差别在于元组是不能修改的

只要将一些值用逗号分隔，就能自动创建一个元组

```
>>> 1, 2, 3 
(1, 2, 3)

>>> (1, 2, 3) 
(1, 2, 3)

>>> () 
()

>>> 42 
42 

>>> 42, 
(42,)

>>> (42,) 
(42,)

>>> 3 * (40 + 2) 
126 
>>> 3 * (40 + 2,) 
(42, 42, 42)
```

函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组

```
>>> tuple([1, 2, 3]) 
(1, 2, 3) 

>>> tuple('abc') 
('a', 'b', 'c') 

>>> tuple((1, 2, 3)) 
(1, 2, 3)
```

```
>>> x = 1, 2, 3 
>>> x[1] 
2 

>>> x[0:2] 
(1, 2)
```

元组的切片也是元组，就像列表的切片也是列表一样

### 2.5 小结

- **序列**：序列是一种数据结构，其中的元素带编号（编号从0开始）。列表、字符串和元组都属于序列，其中列表是可变的（你可修改其内容），而元组和字符串是不可变的（一旦创建，内容就是固定的）。要访问序列的一部分，可使用切片操作：提供两个指定切片起始和结束位置的索引。要修改列表，可给其元素赋值，也可使用赋值语句给切片赋值。
- **成员资格**：要确定特定的值是否包含在序列（或其他容器）中，可使用运算符in。将运算符in用于字符串时情况比较特殊——这样可查找子串。
- **方法**：一些内置类型（如列表和字符串，但不包括元组）提供了很多有用的方法。方法有点像函数，只是与特定的值相关联。方法是面向对象编程的一个重要方面，这将在第7
  章介绍

#### 2.5.1 本章介绍的新函数


| 函 数         | 描 述                                          |
| :------------ | :--------------------------------------------- |
| len(seq)      | 返回序列的长度                                 |
| list(seq)     | 将序列转换为列表                               |
| max(args)     | 返回序列或一组参数中的最大值                   |
| min(args)     | 返回序列和一组参数中的最小值                   |
| reversed(seq) | 让你能够反向迭代序列                           |
| sorted(seq)   | 返回一个有序列表，其中包含指定序列中的所有元素 |
| tuple(seq)    | 将序列转换为元组                               |

#### 2.5.2 预告

跳过SKIP

## 第3章 使用字符串

### 3.1 字符串基本操作

所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的

```
>>> website = 'http://www.python.org' 
>>> website[-3:] = 'com' 
Traceback (most recent call last): 
 File "<pyshell#19>", line 1, in ? 
 website[-3:] = 'com' 
TypeError: object doesn't support slice assignment
```

### 3.2 设置字符串的格式: 精简版

使用字符串格式设置运算符——百分号

```
>>> format = "Hello, s. s enough for ya?" % %
>>> values = ('world', 'Hot') 
>>> format values %
'Hello, world. Hot enough for ya?'
```

%s称为转换说明符，指出了要将值插入什么地方
s意味着将值视为字符串进行格式设置
%.3f将值的格式设置为包含3位小数的浮点数

另一种解决方案是所谓的模板字符串

```
>>> from string import Template 
>>> tmpl = Template("Hello, $who! $what enough for ya?") 
>>> tmpl.substitute(who="Mars", what="Dusty") 
'Hello, Mars! Dusty enough for ya?'
```

在最简单的情况下，替换字段没有名称或将索引用作名称

```
>>> "{}, {} and {}".format("first", "second", "third") 
'first, second and third' 

>>> "{0}, {1} and {2}".format("first", "second", "third") 
'first, second and third'

>>> "{3} {0} {2} {1} {3} {0}".format("be", "not", "or", "to") 
'to be or not to be'
```

```
>>> from math import pi 
>>> "{name} is approximately {value:.2f}.".format(value=pi, name="π") 
'π is approximately 3.14.'
```

关键字参数的排列顺序无关紧要
指定了格式说明符.2f，并使用冒号将其与字段名隔开

```
>>> "{name} is approximately {value}.".format(value=pi, name="π") 
'π is approximately 3.141592653589793.'
```

如果变量与替换字段同名，还可使用一种简写

```
>>> from math import e 
>>> f"Euler's constant is roughly {e}." 
"Euler's constant is roughly 2.718281828459045."

>>> "Euler's constant is roughly {e}.".format(e=e) 
"Euler's constant is roughly 2.718281828459045."
```

### 3.3 设置字符串的格式: 完整版

每个值都被插入字符串中，以替换用花括号括起的替换字段

```
>>> "{{ceci n'est pas une replacement field}}".format() 
"{ceci n'est pas une replacement field}"
```

- **字段名**：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段。除指定值外，还可指定值的特定部分，如列表的元素
- **转换标志**：跟在叹号后面的单个字符。当前支持的字符包括r（表示repr）、s（表示str）
  和a（表示ascii）。如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转换为字符串，再做进一步的格式设置
- **格式说明符**：跟在冒号后面的表达式（这种表达式是使用微型格式指定语言表示的）。格式说明符让我们能够详细地指定最终的格式，包括格式类型（如字符串、浮点数或十六进制数），字段宽度和数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式

#### 3.3.1 替换字段名

```
>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3) 
'3 1 4 2'

>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3) 
'3 2 4 1'

>>> fullname = ["Alfred", "Smoketoomuch"] 
>>> "Mr {name[1]}".format(name=fullname) 
'Mr Smoketoomuch' 

>>> import math 
>>> tmpl = "The {mod.__name__} module defines the value {mod.pi} for π" 
>>> tmpl.format(mod=math) 
'The math module defines the value 3.141592653589793 for π'
```

#### 3.3.2 基本转换

```
>>> print("{pi!s} {pi!r} {pi!a}".format(pi="π")) 
π 'π' '\u03c0'
```

上述三个标志（s、r和a）指定分别使用str、repr和ascii进行转换

可在格式说明（即冒号后面）使用字符f(表示定点数)

```
>>> "The number is {num}".format(num=42) 
'The number is 42' 

>>> "The number is {num:f}".format(num=42) 
'The number is 42.000000'

>>> "The number is {num:b}".format(num=42) 
'The number is 101010'
```


| 类型 | 含 义                                                                                           |
| :--- | :---------------------------------------------------------------------------------------------- |
| b    | 将整数表示为二进制数                                                                            |
| c    | 将整数解读为Unicode码点                                                                         |
| d    | 将整数视为十进制数进行处理，这是整数默认使用的说明符                                            |
| e    | 使用科学表示法来表示小数（用e来表示指数）                                                       |
| E    | 与e相同，但使用E来表示指数                                                                      |
| f    | 将小数表示为定点数                                                                              |
| F    | 与f相同，但对于特殊值（nan和inf），使用大写表示                                                 |
| g    | 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数 |
| G    | 与g相同，但使用大写来表示指数和特殊值                                                           |
| n    | 与g相同，但插入随区域而异的数字分隔符                                                           |
| o    | 将整数表示为八进制数                                                                            |
| s    | 保持字符串的格式不变，这是默认用于字符串的说明符                                                |
| x    | 将整数表示为十六进制数并使用小写字母                                                            |
| X    | 与x相同，但使用大写字母                                                                         |
| %    | 将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）                                 |

#### 3.3.3 宽度、精度和千位分隔符

```
>>> "{num:10}".format(num=3) 
' 3' 

>>> "{name:10}".format(name="Bob") 
'Bob '
```

数和字符串的对齐方式不同

精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点

```
>>> "Pi day is {pi:.2f}".format(pi=pi) 
'Pi day is 3.14'
```

可同时指定宽度和精度

```
>>> "{pi:10.2f}".format(pi=pi) 
' 3.14'
```

可使用逗号来指出你要添加千位分隔符

```
>>> 'One googol is {:,}'.format(10**100) 
'One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00 
0,000,000,000,000,000,000,000,000,000,000,000,000,000,000'
```

#### 3.3.4 符号、对齐和用 0 填充

在指定宽度和精度的数前面，可添加一个标志
这个标志可以是零、加号、减号或空格，其中零表示使用0来填充数字

```
>>> '{:010.2f}'.format(pi) 
'0000003.14'
```

要指定左对齐、右对齐和居中，可分别使用<、>和^

```
>>> print('{0:<10.2f}\n{0:^10.2f}\n{0:>10.2f}'.format(pi)) 
3.14 
 3.14 
  3.14
```

可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充

```
>>> "{:$^15}".format(" WIN BIG ") 
'$$$ WIN BIG $$$'
```

说明符=，它指定将填充字符放在符号和数字之间

```
>>> print('{0:10.2f}\n{1:10.2f}'.format(pi, -pi)) 
    3.14 
   -3.14 
   
>>> print('{0:10.2f}\n{1:=10.2f}'.format(pi, -pi)) 
    3.14 
-   3.14
```

正数加上符号，可使用说明符+

```
>>> print('{0:-.2}\n{1:-.2}'.format(pi, -pi)) #默认设置
3.1 
-3.1 

>>> print('{0:+.2}\n{1:+.2}'.format(pi, -pi)) 
+3.1 
-3.1 

>>> print('{0: .2}\n{1: .2}'.format(pi, -pi)) 
 3.1 
-3.1
```

井号（#）选项，你可将其放在符号说明符和宽度之间（如果指定了这两种设置）。这个选项将触发另一种转换方式，转换细节随类型而异

```
>>> "{:b}".format(42) 
'101010' 

>>> "{:#b}".format(42) 
'0b101010'
```

对于各种十进制数，它要求必须包含小数点

```
>>> "{:g}".format(42) 
'42' 

>>> "{:#g}".format(42) 
'42.0000'
```

### 3.4 字符串方法

跳过SKIP

#### 3.4.1 center

方法center通过在两边添加填充字符（默认为空格）让字符串居中

```
>>> "The Middle by Jimmy Eat World".center(39) 
' The Middle by Jimmy Eat World ' 
>>> "The Middle by Jimmy Eat World".center(39, "*") 
'*****The Middle by Jimmy Eat World*****'
```

#### 3.4.2 find

方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1

```
>>> 'With a moo-moo here, and a moo-moo there'.find('moo') 
7 

>>> title = "Monty Python's Flying Circus" 
>>> title.find('Monty') 
0 

>>> title.find('Python')
6 

>>> title.find('Flying') 
15 

>>> title.find('Zirquss') 
-1

>>> subject = '$$$ Get rich now!!! $$$' 
>>> subject.find('$$$') 
0

>>> subject = '$$$ Get rich now!!! $$$' 
>>> subject.find('$$$') 
0 

>>> subject.find('$$$', 1) # 只指定了起点
20 

>>> subject.find('!!!') 
16 

>>> subject.find('!!!', 0, 16) # 同时指定了起点和终点
-1
```

#### 3.4.3 join

join是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素

```
>>> seq = [1, 2, 3, 4, 5] 
>>> sep = '+' 
>>> sep.join(seq) # 尝试合并一个数字列表
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
TypeError: sequence item 0: expected string, int found 
>>> seq = ['1', '2', '3', '4', '5'] 
>>> sep.join(seq) # 合并一个字符串列表
'1+2+3+4+5' 
>>> dirs = '', 'usr', 'bin', 'env' 
>>> '/'.join(dirs) 
'/usr/bin/env' 
>>> print('C:' + '\\'.join(dirs)) 
C:\usr\bin\env
```

#### 3.4.4 lower

方法lower返回字符串的小写版本

```
>>> 'Trondheim Hammer Dance'.lower() 
'trondheim hammer dance'
```

#### 3.4.5 replace

方法replace将指定子串都替换为另一个字符串，并返回替换后的结果

```
>>> 'This is a test'.replace('is', 'eez') 
'Theez eez a test'
```

#### 3.4.6 split

split是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列

```
>>> '1+2+3+4+5'.split('+') 
['1', '2', '3', '4', '5'] 

>>> '/usr/bin/env'.split('/') 
['', 'usr', 'bin', 'env'] 

>>> 'Using the default'.split() 
['Using', 'the', 'default']
```

#### 3.4.7 strip

方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果

```
>>> ' internal whitespace is kept '.strip() 
'internal whitespace is kept'

>>> '*** SPAM * for * everyone!!! ***'.strip(' *!') 
'SPAM * for * everyone'
```

#### 3.4.8 translate

使用translate前必须创建一个转换表

```
>>> table = str.maketrans('cs', 'kz')

>>> 'this is an incredible test'.translate(table) 
'thiz iz an inkredible tezt'
```

#### 3.4.9 判断字符串是否满足特定的条件

很多字符串方法都以is打头，如isspace、isdigit和isupper，它们判断字符串是否具有特定的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回True，否则返回False。

### 3.5 小结

- **字符串格式设置**：求模运算符（%）可用于将值合并为包含转换标志（如%s）的字符串，这让你能够以众多方式设置值的格式，如左对齐或右对齐，指定字段宽度和精度，添加符号（正号或负号）以及在左边填充0等。
- **字符串方法**：字符串有很多方法，有些很有用（如split和join），有些很少用到（如istitle和capitalize）。

#### 3.5.1 本章介绍的新函数


| 函 数                       | 描 述                                                                     |
| :-------------------------- | :------------------------------------------------------------------------ |
| string.capwords(s\[, sep\]) | 使用split根据sep拆分s，将每项的首字母大写，再以空格为分隔符将它们合并起来 |
| ascii(obj)                  | 创建指定对象的ASCII表示                                                   |

## 第4章 当索引行不通时

### 4.1 字典的用途

下面是Python字典的一些用途：

- 表示棋盘的状态，其中每个键都是由坐标组成的元组；
- 存储文件修改时间，其中的键为文件名；
- 数字电话/地址簿。

### 4.2 创建和使用字典

```python
phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
```

字典由**键**及其相应的**值**组成，这种键值对称为**项**（item）
每个键与其值之间都用冒号（:）分隔，项之间用逗号分隔，而整个字典放在花括号内
空字典（没有任何项）用两个花括号表示，类似于下面这样：{}

#### 4.2.1 函数 dict

可使用函数dict从其他映射（如其他字典）或键值对序列创建字典

```
>>> items = [('name', 'Gumby'), ('age', 42)] 
>>> d = dict(items) 
>>> d 
{'age': 42, 'name': 'Gumby'} 

>>> d['name'] 
'Gumby'
```

还可使用关键字实参来调用这个函数

```
>>> d = dict(name='Gumby', age=42) 
>>> d 
{'age': 42, 'name': 'Gumby'}
```

#### 4.2.2 基本的字典操作

字典的基本行为在很多方面都类似于序列。

- len(d)返回字典d包含的项（键值对）数。
- d\[k\]返回与键k相关联的值。
- d\[k\] = v将值v关联到键k。
- del d\[k\]删除键为k的项。
- k in d检查字典d是否包含键为k的项

虽然字典和列表有多个相同之处，但也有一些重要的不同之处

- 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组。
- 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。
- 成员资格：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in
  l（其中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。

```
>>> x = [] 
>>> x[42] = 'Foobar' 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
IndexError: list assignment index out of range 

>>> x = {} 
>>> x[42] = 'Foobar' 
>>> x 
{42: 'Foobar'}
```

#### 4.2.3 将字符串格式设置功能用于字典

```
>>> phonebook 
{'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'} 

>>> "Cecil's phone number is {Cecil}.".format_map(phonebook) 
"Cecil's phone number is 3258."
```

#### 4.2.4 字典方法

1. clear

    方法clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不返回（或者说返回None）

    ```
    >>> d = {} 
    >>> d['name'] = 'Gumby' 
    >>> d['age'] = 42 
    >>> d 
    {'age': 42, 'name': 'Gumby'} 

    >>> returned_value = d.clear() 
    >>> d 
    {} 

    >>> print(returned_value) 
    None
    ```

    看两个场景

    ```
    >>> x = {} 
    >>> y = x 
    >>> x['key'] = 'value' 
    >>> y 
    {'key': 'value'} 
    >>> x = {} 
    >>> x = {} 
    {'key': 'value'}

    >>> x = {} 
    >>> y = x 
    >>> x['key'] = 'value' 
    >>> y 
    {'key': 'value'} 
    >>> x.clear() 
    >>> y 
    {}
    ```

    在这两个场景中，x和y最初都指向同一个字典。在第一个场景中，我通过将一个空字典赋给x来“清空”它。这对y没有任何影响，它依然指向原来的字典。这种行为可能正是你想要的，但要删除原来字典的所有元素，必须使用clear。如果这样做，y也将是空的，如第二个场景所示

2. copy

    方法copy返回一个新字典，其包含的键值对与原来的字典相同（这个方法执行的是浅复制，因为值本身是原件，而非副本）

    ```
    >>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} 
    >>> y = x.copy() 
    >>> y['username'] = 'mlh' 
    >>> y['machines'].remove('bar') 
    >>> y 
    {'username': 'mlh', 'machines': ['foo', 'baz']} 
    >>> x 
    {'username': 'admin', 'machines': ['foo', 'baz']}
    ```

    如你所见，当替换副本中的值时，原件不受影响。然而，如果修改副本中的值（就地修改而不是替换），原件也将发生变化，因为原件指向的也是被修改的值（如这个示    例中的'machines'列表所示）

    为避免这种问题，一种办法是执行深复制，即同时复制值及其包含的所有值，等等。为此，可使用模块copy中的函数deepcopy

    ```
    >>> from copy import deepcopy 
    >>> d = {} 
    >>> d['names'] = ['Alfred', 'Bertrand'] 
    >>> c = d.copy() 
    >>> dc = deepcopy(d) 
    >>> d['names'].append('Clive') 
    >>> c 
    {'names': ['Alfred', 'Bertrand', 'Clive']} 
    >>> dc 
    {'names': ['Alfred', 'Bertrand']}
    ```

3. fromkeys

    方法fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None

    ```
    >>> {}.fromkeys(['name', 'age']) 
    {'age': None, 'name': None}

    >>> dict.fromkeys(['name', 'age'], '(unknown)') 
    {'age': '(unknown)', 'name': '(unknown)'}
    ```

4. get

    方法get为访问字典项提供了宽松的环境。
    通常，如果你试图访问字典中没有的项，将引发错误

    ```
    >>> d = {} 
    >>> print(d['name']) 
    Traceback (most recent call last): 
     File "<stdin>", line 1, in ? 
    KeyError: 'name'
    ```

    而使用get不会这样

    ```
    >>> print(d.get('name')) 
    None

    >>> d.get('name', 'N/A') 
    'N/A'
    ```

5. items

    方法items返回一个包含所有字典项的列表，其中每个元素都为(key,
    value)的形式。字典项在列表中的排列顺序不确定

    ```
    >>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0} 
    >>> d.items() 
    dict_items([('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')])
    ```

    返回值属于一种名为字典视图的特殊类型

    可确定其长度以及对其执行成员资格检查

    ```
    >>> it = d.items() 
    >>> len(it) 
    3 

    >>> ('spam', 0) in it 
    True
    ```

    视图的一个优点是不复制，它们始终是底层字典的反映，即便你修改了底层字典亦如此

    ```
    >>> d['spam'] = 1 
    >>> ('spam', 0) in it 
    False 

    >>> d['spam'] = 0 
    >>> ('spam', 0) in it 
    True
    ```

    要将字典项复制到列表中

    ```
    >>> list(d.items()) 
    [('spam', 0), ('title', 'Python Web Site'), ('url', 'http://www.python.org')]
    ```

6. keys

    方法keys返回一个字典视图，其中包含指定字典中的键

7. pop

    方法pop可用于获取与指定键相关联的值，并将该键值对从字典中删除。

    ```
    >>> d = {'x': 1, 'y': 2} 
    >>> d.pop('x') 
    1 
    >>> d 
    {'y': 2}
    ```

8. popitem

    方法popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表

    ```
    >>> d = {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'} 
    >>> d.popitem() 
    ('url', 'http://www.python.org') 

    >>> d 
    {'spam': 0, 'title': 'Python Web Site'}
    ```

    虽然popitem类似于列表方法pop，但字典没有与append（它在列表末尾添加一个元素）对应的方法。这是因为字典是无序的，类似的方法毫无意义

    > 如果希望方法popitem以可预测的顺序弹出字典项，请参阅模块collections中的OrderedDict类

9. setdefault

    方法setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键值对

    ```
    >>> d = {} 
    >>> d.setdefault('name', 'N/A') 
    'N/A' 
    >>> d 
    {'name': 'N/A'} 
    >>> d['name'] = 'Gumby' 
    >>> d.setdefault('name', 'N/A') 
    'Gumby' 
    >>> d 
    {'name': 'Gumby'}
    ```

    指定的键不存在时，setdefault返回指定的值并相应地更新字典

    如果指定的键存在，就返回其值，并保持字典不变。与get一样，值是可选的；如果没有指定，默认为None

    ```
    >>> d = {} 
    >>> print(d.setdefault('name')) 
    None 

    >>> d 
    {'name': None}
    ```

10. update

    方法update使用一个字典中的项来更新另一个字典

    ```
    >>> d = { 
    ... 'title': 'Python Web Site', 
    ... 'url': 'http://www.python.org', 
    ... 'changed': 'Mar 14 22:09:15 MET 2016' 
    ... }

    >>> x = {'title': 'Python Language Website'} 
    >>> d.update(x) 
    >>> d 
    {'url': 'http://www.python.org', 'changed': 
    'Mar 14 22:09:15 MET 2016', 'title': 'Python Language Website'}
    ```

    对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它

11. values

    方法values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视图可能包含重复的值

    ```
    >>> d = {} 
    >>> d[1] = 1 
    >>> d[2] = 2 
    >>> d[3] = 3 
    >>> d[4] = 1 
    >>> d.values() 
    dict_values([1, 2, 3, 1])
    ```

### 4.3 小结

- 映射：映射让你能够使用任何不可变的对象（最常用的是字符串和元组）来标识其元素。Python只有一种内置的映射类型，那就是字典。
- 将字符串格式设置功能用于字典：要对字典执行字符串格式设置操作，不能使用format和命名参数，而必须使用format_map。
- 字典方法：字典有很多方法，这些方法的调用方式与列表和字符串的方法相同

#### 4.3.1 本章介绍的新函数


| 函 数     | 描 述                              |
| :-------- | :--------------------------------- |
| dict(seq) | 从键值对、映射或关键字参数创建字典 |

## 第5章 条件、循环及其他语句

### 5.1 再谈 print 和 import

#### 5.1.1 打印多个参数

```
>>> print('Age:', 42) 
Age: 42

>>> name = 'Gumby' 
>>> salutation = 'Mr.' 
>>> greeting = 'Hello,' 
>>> print(greeting, salutation, name) 
Hello, Mr. Gumby
```

可自定义分隔符

```
>>> print("I", "wish", "to", "register", "a", "complaint", sep="_") 
I_wish_to_register_a_complaint
```

可自定义结束字符串，以替换默认的换行符

```
print('Hello,', end='') 
print('world!')

Hello, world!
```

#### 5.1.2 导入时重命名

```
>>> import math as foobar 
>>> foobar.sqrt(4) 
2.0

>>> from math import sqrt as foobar 
>>> foobar(4) 
2.0

from module1 import open as open1 
from module2 import open as open2
```

### 5.2 赋值魔法

#### 5.2.1 序列解包

可同时（并行）给多个变量赋值

```
>>> x, y, z = 1, 2, 3 
>>> print(x, y, z) 
1 2 3
```

交换多个变量的值

```
>>> x, y = y, x 
>>> print(x, y, z) 
2 1 3
```

这里执行的操作称为序列解包（或可迭代对象解包）：将一个序列（或任何可迭代对象）解包，并将得到的值存储到一系列变量中

```
>>> values = 1, 2, 3 
>>> values 
(1, 2, 3) 
>>> x, y, z = values 
>>> x 
1
```

假设要从字典中随便获取（或删除）一个键值对，可使用方法popitem，它随便获取一个键值对并以元组的方式返回。接下来，可直接将返回的元组解包到两个变量中

```
>>> scoundrel = {'name': 'Robin', 'girlfriend': 'Marion'} 
>>> key, value = scoundrel.popitem() 
>>> key 
'girlfriend' 
>>> value 
'Marion'
```

解包的序列包含的元素个数必须与你在等号左边列出的目标个数相同，否则Python将引发异常

```
>>> x, y, z = 1, 2 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
ValueError: need more than 2 values to unpack 

>>> x, y, z = 1, 2, 3, 4 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
ValueError: too many values to unpack
```

可使用星号运算符（*）来收集多余的值，这样无需确保值和变量的个数相同

```
>>> a, b, *rest = [1, 2, 3, 4] 
>>> rest 
[3, 4]

>>> name = "Albus Percival Wulfric Brian Dumbledore" 
>>> first, *middle, last = name.split() 
>>> middle 
['Percival', 'Wulfric', 'Brian']

>>> a, *b, c = "abc" 
>>> a, b, c 
('a', ['b'], 'c')
```

#### 5.2.2 链式赋值

链式赋值是一种快捷方式，用于将多个变量关联到同一个值

```python
x = y = somefunction()

#等价
y = somefunction() 
x = y

#不等价
x = somefunction() 
y = somefunction()
```

#### 5.2.3 增强赋值

```
>>> x = 2 
>>> x += 1 
>>> x *= 2 
>>> x 
6

>>> fnord = 'foo' 
>>> fnord += 'bar' 
>>> fnord *= 2 
>>> fnord 
'foobarfoobar'
```

### 5.3 代码块：缩进的乐趣

```
this is a line 
this is another line: 
 this is another block 
 continuing the same block 
 the last line of this block 
phew, there we escaped the inner block
```

### 5.4 条件和条件语句

#### 5.4.1 这正是布尔值的用武之地

下面的值都将被解释器视为假：
False None 0 "" () \[\] {}

```
>>> True 
True 
>>> False 
False 
>>> True == 1 
True 
>>> False == 0 
True 
>>> True + False + 42 
43

>>> bool('I think, therefore I am') 
True 
>>> bool(42) 
True 
>>> bool('') 
False 
>>> bool(0) 
False
```

> 虽然[]和""都为假（即bool([]) == bool("") == False），但它们并不相等（即[] !=
> ""）。对其他各种为假的对象来说，情况亦如此（一个更显而易见的例子是() != False）

#### 5.4.2 有条件地执行和 if 语句

```python
name = input('What is your name? ') 
if name.endswith('Gumby'): 
 print('Hello, Mr. Gumby')
```

#### 5.4.3 else 子句

```python
name = input('What is your name?') 
if name.endswith('Gumby'): 
 print('Hello, Mr. Gumby') 
else: 
 print('Hello, stranger')
 
status = "friend" if name.endswith("Gumby") else "stranger"
```

#### 5.4.4 elif 子句

```python
num = int(input('Enter a number: ')) 
if num > 0: 
 print('The number is positive') 
elif num < 0: 
 print('The number is negative') 
else: 
 print('The number is zero')
```

#### 5.4.5 代码块嵌套

```python
name = input('What is your name? ') 
if name.endswith('Gumby'): 
    if name.startswith('Mr.'): 
        print('Hello, Mr. Gumby') 
    elif name.startswith('Mrs.'): 
        print('Hello, Mrs. Gumby') 
    else: 
        print('Hello, Gumby') 
else: 
    print('Hello, stranger')
```

#### 5.4.6 更复杂的条件

1. 比较运算符

    在条件表达式中，最基本的运算符可能是比较运算符，它们用于执行比较
    
    
    | 表 达 式   | 描 述                      |
    | :--------- | :------------------------- |
    | x == y     | x 等于y                    |
    | x < y      | x小于y                     |
    | x > y      | x大于y                     |
    | x >= y     | x大于或等于y               |
    | x <= y     | x小于或等于y               |
    | x != y     | x不等于y                   |
    | x is y     | x和y是同一个对象           |
    | x is not y | x和y是不同的对象           |
    | x in y     | x是容器（如序列）y的成员   |
    | x not in y | x不是容器（如序列）y的成员 |

2. 布尔运算符

    ```python
    number = int(input('Enter a number between 1 and 10: ')) 
    if number <= 10 and number >= 1: 
     print('Great!') 
    else: 
     print('Wrong!')
    ```

    #### 5.4.7 断言

    ```python
    if not condition: 
     crash program
    ```

    程序在错误条件出现时立即崩溃

    ```
    >>> age = 10 
    >>> assert 0 < age < 100 
    >>> age = -1 
    >>> assert 0 < age < 100 
    Traceback (most recent call last): 
     File "<stdin>", line 1, in ? 
    AssertionError
    ```

    ```
    >>> age = -1 
    >>> assert 0 < age < 100, 'The age must be realistic' 
    Traceback (most recent call last): 
     File "<stdin>", line 1, in ? 
    AssertionError: The age must be realistic
    ```

### 5.5 循环

#### 5.5.1 while 循环

```python
x = 1 
while x <= 100: 
 print(x) 
 x += 1
 
name = '' 
while not name: 
 name = input('Please enter your name: ') 
print('Hello, {}!'.format(name))
```

#### 5.5.2 for 循环

```python
words = ['this', 'is', 'an', 'ex', 'parrot'] 
for word in words: 
 print(word)
 
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
for number in numbers: 
 print(number)
```

#### 5.5.3 迭代字典

```python
d = {'x': 1, 'y': 2, 'z': 3} 
for key in d: 
 print(key, 'corresponds to', d[key])
 
for key, value in d.items(): 
 print(key, 'corresponds to', value)
```

#### 5.5.4 一些迭代工具

1. 并行迭代

    ```python
    names = ['anne', 'beth', 'george', 'damon'] 
    ages = [12, 45, 32, 102]
    for i in range(len(names)): 
     print(names[i], 'is', ages[i], 'years old')
    ```

    置函数zip将两个序列“缝合”起来，并返回一个由元组组成的序列

    ```
    >>> list(zip(names, ages)) 
    [('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
    ```

    “缝合”后，可在循环中将元组解包

    ```python
    for name, age in zip(names, ages): 
     print(name, 'is', age, 'years old')
    ```

    当序列的长度不同时，函数zip将在最短的序列用完后停止“缝合”

    ```
    >>> list(zip(range(5), range(100000000))) 
    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
    ```

2. 迭代时获取索引

    ```python
    for string in strings: 
     if 'xxx' in string: 
     index = strings.index(string) # 在字符串列表中查找字符串
     strings[index] = '[censored]'

    index = 0 
    for string in strings: 
     if 'xxx' in string: 
     strings[index] = '[censored]' 
     index += 1
    
    for index, string in enumerate(strings): 
     if 'xxx' in string: 
     strings[index] = '[censored]'
    ```

3. 反向迭代和排序后再迭代

    ```
    >>> sorted([4, 3, 6, 8, 3]) 
    [3, 3, 4, 6, 8] 
    >>> sorted('Hello, world!') 
    [' ', '!', ',', 'H', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', 'w'] 
    >>> list(reversed('Hello, world!')) 
    ['!', 'd', 'l', 'r', 'o', 'w', ' ', ',', 'o', 'l', 'l', 'e', 'H'] 
    >>> ''.join(reversed('Hello, world!')) 
    '!dlrow ,olleH'
    ```

#### 5.5.5 跳出循环

1. break

    ```python
    from math import sqrt 
    for n in range(99, 0, -1): 
     root = sqrt(n) 
     if root == int(root): 
     print(n) 
     break
    ```

2. continue

    ```python
    for x in seq: 
     if condition1: continue 
     if condition2: continue 
     if condition3: continue 
     do_something() 
     do_something_else() 
     do_another_thing() 
     etc()
    ```

3. while True/break成例

    ```python
    word = 'dummy' 
    while word: 
     word = input('Please enter a word: ') 
     # 使用这个单词做些事情：
     print('The word was', word)
    
    while True: 
     word = input('Please enter a word: ') 
     if not word: break 
     # 使用这个单词做些事情：
     print('The word was ', word)
    ```

#### 5.5.6 循环中的 else 子句

```python
broke_out = False 
for x in seq: 
 do_something(x) 
 if condition(x): 
 broke_out = True 
 break 
 do_something_else(x) 
if not broke_out: 
 print("I didn't break out!")
 
from math import sqrt 
for n in range(99, 81, -1): 
 root = sqrt(n) 
 if root == int(root): 
 print(n) 
 break 
else: 
 print("Didn't find it!")
```

### 5.6 简单推导

```
>>> [x * x for x in range(10)] 
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> [x*x for x in range(10) if x 3 == 0] %
[0, 9, 36, 81]

>>> [(x, y) for x in range(3) for y in range(3)] 
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

```python
result = [] 
for x in range(3): 
 for y in range(3) 
 result.append((x, y))
```

```
>>> girls = ['alice', 'bernice', 'clarice'] 
>>> boys = ['chris', 'arnold', 'bob'] 
>>> [b+'+'+g for b in boys for g in girls if b[0] == g[0]] 
['chris+clarice', 'arnold+alice', 'bob+bernice']
```

### 5.7 三人行

#### 5.7.1 什么都不做

```python
if name == 'Ralph Auldus Melish': 
 print('Welcome!') 
elif name == 'Enid': 
 # 还未完成……
 pass 
elif name == 'Bill Gates': 
 print('Access Denied')
```

#### 5.7.2 使用 del 删除

```
>>> x = 1 
>>> del x 
>>> x 
Traceback (most recent call last): 
 File "<pyshell#255>", line 1, in ? 
 x 
NameError: name 'x' is not defined
```

#### 5.7.3 使用 exec 和 eval 执行字符串及计算其结果

1. exec

    函数exec将字符串作为代码执行

    ```
    >>> exec("print('Hello, world!')") 
    Hello, world!

    >>> from math import sqrt 
    >>> exec("sqrt = 1") 
    >>> sqrt(4) 
    Traceback (most recent call last): 
     File "<pyshell#18>", line 1, in ? 
     sqrt(4) 
    TypeError: object is not callable: 1
    ```

    添加第二个参数——字典，用作代码字符串的命名空间

    ```
    >>> from math import sqrt 
    >>> scope = {} 
    >>> exec('sqrt = 1', scope) 
    >>> sqrt(4) 
    2.0 
    >>> scope['sqrt'] 
    1

    >>> len(scope) 
    2 
    >>> scope.keys() 
    ['sqrt', '__builtins__']
    ```

2. eval

    eval计算用字符串表示的Python表达式的值，并返回结果

    ```
    >>> eval(input("Enter an arithmetic expression: ")) 
    Enter an arithmetic expression: 6 + 18 * 2 
    42
    ```

### 5.8 小结

- **打印语句**：你可使用print语句来打印多个用逗号分隔的值。如果print语句以逗号结尾，后续print语句将在当前行接着打印。
- **导入语句**：有时候，你不喜欢要导入的函数的名称——可能是因为你已将这个名称用作他用。在这种情况下，可使用import
  ... as ...语句在本地重命名函数。
- **赋值语句**：通过使用奇妙的序列解包和链式赋值，可同时给多个变量赋值；而通过使用增强赋值，可就地修改变量。
- **代码块**：代码块用于通过缩进将语句编组。代码块可用于条件语句和循环中，还可用于函数和类定义中（这将在本书后面介绍）。
- **条件语句**：条件语句根据条件（布尔表达式）决定是否执行后续代码块。通过使用if/elif/else，可将多个条件语句组合起来。条件语句的一个变种是条件表达式，如a
  if b else c。
- **断言**：断言断定某件事（一个布尔表达式）为真，可包含说明为何必须如此的字符串。如果指定的表达式为假，断言将导致程序停止执行（或引发第8章将介绍的异常）。最好尽早将错误揪出来，免得它潜藏在程序中，直到带来麻烦。
- **循环**：你可针对序列中的每个元素（如特定范围内的每个数）执行代码块，也可在条件为真时反复执行代码块。要跳过代码块中余下的代码，直接进入下一次迭代，可使用continue语句；要跳出循环，可使用break语句。另外，你还可在循环末尾添加一个else子句，它将在没有执行循环中的任何break语句时执行。
- **推导**：推导并不是语句，而是表达式。它们看起来很像循环，因此我将它们放在循环中讨论。通过列表推导，可从既有列表创建出新列表，这是通过对列表元素调用函数、剔除不想要的函数等实现的。推导功能强大，但在很多情况下，使用普通循环和条件语句也可完成任务，且代码的可读性可能更高。使用类似于列表推导的表达式可创建出字典。
- **pass、del、exec和eval**：pass语句什么都不做，但适合用作占位符。del语句用于删除变量或数据结构的成员，但不能用于删除值。函数exec用于将字符串作为Python程序执行。函数eval计算用字符串表示的表达式并返回结果

#### 5.8.1 本章介绍的新函数


| 函 数                                   | 描 述                                                                         |
| :-------------------------------------- | :---------------------------------------------------------------------------- |
| chr(n)                                  | 返回一个字符串，其中只包含一个字符，这个字符对应于传入的顺序值n（0 ≤n < 256） |
| eval(source\[,globals\[,locals\]\])     | 计算并返回字符串表示的表达式的结果                                            |
| exec(source\[, globals\[, locals\]\])   | 将字符串作为语句执行                                                          |
| enumerate(seq)                          | 生成可迭代的索引值对                                                        |
| ord(c)                                  | 接受一个只包含一个字符的字符串，并返回这个字符的顺序值（一个整数）            |
| range(\[start,\] stop\[, step\])        | 创建一个由整数组成的列表                                                      |
| reversed(seq)                           | 按相反的顺序返回seq中的值，以便用于迭代                                       |
| sorted(seq\[,cmp\]\[,key\]\[,reverse\]) | 返回一个列表，其中包含seq中的所有值且这些值是经过排序的                       |
| xrange(\[start,\] stop\[, step\])       | 创建一个用于迭代的xrange对象                                                  |
| zip(seq1, seq2,...)                     | 创建一个适合用于并行迭代的新序列                                              |

## 第6章 抽象

### 6.1 懒惰是一种美德

斐波那契数

```python
fibs = [0, 1] 
for i in range(8): 
 fibs.append(fibs[-2] + fibs[-1])
```

### 6.2 抽象和结构

如下载网页、计算使用频率、打印每个单词的使用频率

```python
page = download_page() 
freqs = compute_frequencies(page) 
for word, freq in freqs: 
 print(word, freq)
```

### 6.3 自定义函数

使用def（表示定义函数）语句

```python
def hello(name): 
 return 'Hello, ' + name + '!'
 
def fibs(num): 
 result = [0, 1] 
 for i in range(num-2): 
 result.append(result[-2] + result[-1]) 
 return result
```

#### 6.3.1 给函数编写文档

文档字符串

```python
def square(x): 
 'Calculates the square of the number x.' 
 return x * x

>>> square.__doc__ 
'Calculates the square of the number x.'
```

> __doc__是函数的一个属性

#### 6.3.2 其实并不是函数的函数

```python
def test(): 
 print('This is printed') 
 return 
 print('This is not')
 
>>> print(x) 
None
```

所有的函数都返回值。如果你没有告诉它们该返回什么，将返回None

### 6.4 参数魔法

#### 6.4.1 值从哪里来

> 在def语句中，位于函数名后面的变量通常称为形参，而调用函数时提供的值称为实参，但本书基本不对此做严格的区分。在很重要的情况下，我会将实参称为值，以便将其与类似于变量的形参区分开来

#### 6.4.2 我能修改参数吗

在函数内部重新关联参数（即给它赋值）时，函数外部的变量不受影响

> 参数存储在局部作用域内

```
>>> names = ['Mrs. Entity', 'Mrs. Thing'] 
>>> n = names[:]
```

现在n和names包含两个**相等**但**不同**的列表。

```
>>> n is names 
False 
>>> n == names 
True
```

1. 为何要修改参数

    编写一个程序，让它存储姓名，并让用户能够根据名字、中间名或姓找人

    ```python
    storage = {} 
    storage['first'] = {} 
    storage['middle'] = {} 
    storage['last'] = {}
    ```

    要将作者加入这个数据结构中，可以像下面这样做

    ```python
    me = 'Magnus Lie Hetland' 
    storage['first']['Magnus'] = [me] 
    storage['middle']['Lie'] = [me] 
    storage['last']['Hetland'] = [me]
    ```

    要获取中间名为Lie的人员名单

    ```
    >>> storage['middle']['Lie'] 
    ['Magnus Lie Hetland']
    ```

    添加我的妹妹

    ```python
    >>> my_sister = 'Anne Lie Hetland' 
    >>> storage['first'].setdefault('Anne', []).append(my_sister) 
    >>> storage['middle'].setdefault('Lie', []).append(my_sister) 
    >>> storage['last'].setdefault('Hetland', []).append(my_sister) 
    >>> storage['first']['Anne'] 
    ['Anne Lie Hetland'] 
    >>> storage['middle']['Lie'] 
    ['Magnus Lie Hetland', 'Anne Lie Hetland']
    ```

    来创建一个初始化数据结构的函数

    ```python
    def init(data): 
     data['first'] = {} 
     data['middle'] = {} 
     data['last'] = {}
    
    >>> storage = {} 
    >>> init(storage) 
    >>> storage 
    {'middle': {}, 'last': {}, 'first': {}}
    ```

    > 在字典中，键的排列顺序是不固定的，因此打印字典时，每次的顺序都可能不同。如果你在解释器中打印出来的顺序不同，请不用担心

    编写获取人员姓名的函数，再接着编写存储人员姓名的函数

    ```python
    def lookup(data, label, name): 
     return data[label].get(name)
    
    >>> lookup(storage, 'middle', 'Lie') 
    ['Magnus Lie Hetland']
    ```

    编写将人员存储到数据结构中的函数

    ```python
    def store(data, full_name): 
        names = full_name.split() 
        if len(names) == 2: names.insert(1, '') 
        labels = 'first', 'middle', 'last' 
        for label, name in zip(labels, names): 
            people = lookup(data, label, name) 
            if people: 
                people.append(full_name) 
            else: 
                data[label][name] = [full_name]

    >>> MyNames = {} 
    >>> init(MyNames) 
    >>> store(MyNames, 'Magnus Lie Hetland') 
    >>> lookup(MyNames, 'middle', 'Lie') 
    ['Magnus Lie Hetland']
    >>> store(MyNames, 'Robin Hood') 
    >>> store(MyNames, 'Robin Locksley') 
    >>> lookup(MyNames, 'first', 'Robin') 
    ['Robin Hood', 'Robin Locksley'] 
    >>> store(MyNames, 'Mr. Gumby') 
    >>> lookup(MyNames, 'middle', '') 
    ['Robin Hood', 'Robin Locksley', 'Mr. Gumby']
    ```

    ```
    1. 将参数data和full_name提供给这个函数。这些参数被设置为从外部获得的值。
    2. 通过拆分full_name创建一个名为names的列表。
    3. 如果names的长度为2（只有名字和姓），就将中间名设置为空字符串。
    4. 将'first'、'middle'和'last'存储在元组labels中（也可使用列表，这里使用元组只是为了省略方括号）。
    5. 使用函数zip将标签和对应的名字合并，以便对每个标签名字对执行如下操作：
       - 获取属于该标签和名字的列表；
       - 将full_name附加到该列表末尾或插入一个新列表
    ```

2. 如果参数是不可变的

在有些语言（如C++、Pascal和Ada）中，经常需要给参数赋值并让这种修改影响函数外部的变量。在Python中，没法直接这样做，只能修改参数对象本身

```
>>> def inc(x): return x + 1 
... 
>>> foo = 10 
>>> foo = inc(foo) 
>>> foo 
11

>>> def inc(x): x[0] = x[0] + 1 
... 
>>> foo = [10] 
>>> inc(foo) 
>>> foo 
[11]
```

#### 6.4.3 关键字参数和默认值

有时候，参数的排列顺序可能难以记住，尤其是参数很多时。为了简化调用工作，可指定参数的名称

```python
def hello_1(greeting, name): 
 print('{}, {}!'.format(greeting, name))

>>> hello_1(greeting='Hello', name='world') 
Hello, world!
```

像这样使用名称指定的参数称为**关键字参数**，主要优点是有助于澄清各个参数的作用

```
>>> store('Mr. Brainsample', 10, 20, 13, 5)

>>> store(patient='Mr. Brainsample', hour=10, minute=20, day=13, month=5)
```

关键字参数最大的优点在于，可以指定默认值

```python
def hello_3(greeting='Hello', name='world'): 
 print('{}, {}!'.format(greeting, name))
```

像这样给参数指定默认值后，调用函数时可不提供它！可以根据需要，一个参数值也不提供、提供部分参数值或提供全部参数值

```
>>> hello_3() 
Hello, world! 

>>> hello_3('Greetings') 
Greetings, world! 

>>> hello_3('Greetings', 'universe') 
Greetings, universe!

>>> hello_3(name='Gumby') 
Hello, Gumby!
```

#### 6.4.4 收集参数

```python
def print_params(*params): 
 print(params)
```

参数前面的星号将提供的所有值都放在一个元组中
如果没有可供收集的参数，params将是一个空元组

```
>>> print_params('Testing') 
('Testing',)

>>> print_params(1, 2, 3) 
(1, 2, 3)
```

带星号的参数也可放在其他位置（而不是最后），但不同的是，在这种情况下你需要做些额外的工作：使用名称来指定后续参数

```
>>> def in_the_middle(x, *y, z): 
... print(x, y, z) 
... 

>>> in_the_middle(1, 2, 3, 4, 5, z=7) 
1 (2, 3, 4, 5) 7 

>>> in_the_middle(1, 2, 3, 4, 5, 7) 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
TypeError: in_the_middle() missing 1 required keyword-only argument: 'z'
```

要收集关键字参数，可使用两个星号。

```
>>> def print_params_3(**params): 
... print(params) 
... 

>>> print_params_3(x=1, y=2, z=3) 
{'z': 3, 'x': 1, 'y': 2}
```

```python
def print_params_4(x, y, z=3, *pospar, **keypar): 
 print(x, y, z) 
 print(pospar) 
 print(keypar)
```

```
>>> print_params_4(1, 2, 3, 5, 6, 7, foo=1, bar=2) 
1 2 3 
(5, 6, 7) 
{'foo': 1, 'bar': 2} 
>>> print_params_4(1, 2) 
1 2 3 
() 
{}
```

在姓名存储示例中使用这种技术

```python
def store(data, *full_names): 
    for full_name in full_names: 
        names = full_name.split() 
        if len(names) == 2: names.insert(1, '') 
        labels = 'first', 'middle', 'last' 
        for label, name in zip(labels, names): 
            people = lookup(data, label, name) 
            if people: 
                people.append(full_name) 
            else: 
                data[label][name] = [full_name]
```

#### 6.4.5 分配参数

不是收集参数，而是分配参数。这是通过在调用函数（而不是定义函数）时使用运算符*实现的

```python
def add(x, y): 
    return x + y
params = (1, 2)

>>> add(*params) 
3
```

```
>>> params = {'name': 'Sir Robin', 'greeting': 'Well met'} 
>>> hello_3(**params) 
Well met, Sir Robin!
```

如果在定义和调用函数时都使用*或**，将只传递元组或字典。因此还不如不使用它们，还可省却些麻烦。

```
>>> def with_stars(**kwds): 
... print(kwds['name'], 'is', kwds['age'], 'years old') 
... 
>>> def without_stars(kwds): 
... print(kwds['name'], 'is', kwds['age'], 'years old') 
... 
>>> args = {'name': 'Mr. Gumby', 'age': 42} 
>>> with_stars(**args) 
Mr. Gumby is 42 years old 
>>> without_stars(args) 
Mr. Gumby is 42 years old
```

#### 6.4.6 练习使用参数

```python
def story(**kwds): 
    return 'Once upon a time, there was a ' \ 
        '{job} called {name}.'.format_map(kwds) 
def power(x, y, *others): 
    if others: 
        print('Received redundant parameters:', others) 
    return pow(x, y) 
def interval(start, stop=None, step=1): 
    'Imitates range() for step > 0' 
    if stop is None: # 如果没有给参数stop指定值，
        start, stop = 0, start # 就调整参数start和stop的值
    result = [] 
    i = start # 从start开始往上数
    while i < stop: # 数到stop位置
        result.append(i) # 将当前数的数附加到result末尾
        i += step # 增加到当前数和step（> 0）之和
    return result
```

下面来尝试调用这些函数

```
>>> print(story(job='king', name='Gumby')) 
Once upon a time, there was a king called Gumby. 
>>> print(story(name='Sir Robin', job='brave knight')) 
Once upon a time, there was a brave knight called Sir Robin. 
>>> params = {'job': 'language', 'name': 'Python'} 
>>> print(story(**params)) 
Once upon a time, there was a language called Python. 
>>> del params['job'] 
>>> print(story(job='stroke of genius', **params)) 
Once upon a time, there was a stroke of genius called Python. 
>>> power(2, 3) 
8 
>>> power(3, 2) 
9 
>>> power(y=3, x=2) 
8 
>>> params = (5,) * 2 
>>> power(*params) 
3125 
>>> power(3, 3, 'Hello, world') 
Received redundant parameters: ('Hello, world',) 
27 
>>> interval(10) 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
>>> interval(1, 5) 
[1, 2, 3, 4] 
>>> interval(3, 12, 4) 
[3, 7, 11] 
>>> power(*interval(3, 7)) 
Received redundant parameters: (5, 6) 
81
```

### 6.5 作用域

将变量视为指向值的名称
几乎与使用字典时一样（字典中的键指向值），只是你使用的是“看不见”的字典
这种“看不见的字典”称为命名空间或作用域

```
>>> def foo(): x = 42 
... 
>>> x = 1 
>>> foo() 
>>> x 
1
```

在这里，函数foo修改（重新关联）了变量x，但当你最终查看时，它根本没变

### 6.6 递归

这个函数中的递归称为无穷递归（就像以while
True打头且不包含break和return语句的循环被称为无限循环一样），因为它从理论上说永远不会结束

- **基线条件**（针对最小的问题）：满足这种条件时函数将直接返回一个值。
- **递归条件**：包含一个或多个调用，这些调用旨在解决问题的一部分

#### 6.6.1 两个经典案例：阶乘和幂

```python
def factorial(n): 
 if n == 1: 
 return 1 
 else: 
 return n * factorial(n - 1)
```

#### 6.6.2 另一个经典案例：二分查找

```python
def search(sequence, number, lower, upper): 
    if lower == upper: 
        assert number == sequence[upper] 
        return upper 
    else: 
        middle = (lower + upper) // 2 
        if number > sequence[middle]: 
            return search(sequence, number, middle + 1, upper) 
        else: 
            return search(sequence, number, lower, middle)
```

### 6.7 小结

- **抽象**：抽象是隐藏不必要细节的艺术。通过定义处理细节的函数，可让程序更抽象。
- **函数定义**：函数是使用def语句定义的。函数由语句块组成，它们从外部接受值（参数），并可能返回一个或多个值（计算结果）。
- **参数**：函数通过参数（调用函数时被设置的变量）接收所需的信息。在Python中，参数有两类：位置参数和关键字参数。通过给参数指定默认值，可使其变成可选的。
- **作用域**：变量存储在作用域（也叫命名空间）中。在Python中，作用域分两大类：全局作用域和局部作用域。作用域可以嵌套。
- **递归**：函数可调用自身，这称为递归。可使用递归完成的任何任务都可使用循环来完成，但有时使用递归函数的可读性更高。
- **函数式编程**：Python提供了一些函数式编程工具，其中包括lambda表达式以及函数map、filter和reduce。

### 6.7.1 本章介绍的新函数


| 函 数                             | 描 述                                                      |
| :-------------------------------- | :--------------------------------------------------------- |
| map(func, seq\[, seq, ...\])      | 对序列中的所有元素执行函数                                 |
| filter(func, seq)                 | 返回一个列表，其中包含对其执行函数时结果为真的所有元素     |
| reduce(func, seq\[, initial\])    | 等价于 func(func(func(seq\[0\], seq\[1\]), seq\[2\]), ...) |
| sum(seq)                          | 返回 seq 中所有元素的和                                    |
| apply(func\[, args\[, kwargs\]\]) | 调用函数（还提供要传递给函数的参数）                       |

## 第7章 再谈抽象

### 7.1 对象魔法

- 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。
- 封装：对外部隐藏有关对象工作原理的细节。
- 继承：可基于通用类创建出专用类。

#### 7.1.1 多态

这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异

#### 7.1.2 多态和方法

每当无需知道对象是什么样的就能对其执行操作时，都是多态在起作用

```
>>> 1 + 2 
3 
>>> 'Fish' + 'license' 
'Fishlicense'
```

上述代码表明，加法运算符（+）既可用于数（这里是整数），也可用于字符串（以及其他类型的序列）
重点在于参数可以是任何支持加法的对象

#### 7.1.3 封装

封装（encapsulation）指的是向外部隐藏不必要的细节
属性是归属于对象的变量，就像方法一样。实际上，方法差不多就是与函数相关联的属性

#### 7.1.4 继承

程序员总是想避免多次输入同样的代码

### 7.2 类

#### 7.2.1 类到底是什么

本书前面反复提到了类，并将其用作类型的同义词。从很多方面来说，这正是类的定义——一种对象。每个对象都属于特定的类，并被称为该类的实例。

“云雀”为“鸟类”的子类，而“鸟类”为“云雀”的超类

#### 7.2.2 创建自定义类

```python
__metaclass__ = type # 如果你使用的是Python 2，请包含这行代码
class Person: 
    def set_name(self, name): 
        self.name = name 
    def get_name(self): 
        return self.name 
    def greet(self): 
        print("Hello, world! I'm {}.".format(self.name))
```

```
>>> foo = Person() 
>>> bar = Person() 
>>> foo.set_name('Luke Skywalker') 
>>> bar.set_name('Anakin Skywalker') 
>>> foo.greet() 
Hello, world! I'm Luke Skywalker. 
>>> bar.greet() 
Hello, world! I'm Anakin Skywalker.
```

#### 7.2.3 属性、函数和方法

```
>>> class Class: 
... def method(self): 
... print('I have a self!') 
... 
>>> def function(): 
... print("I don't...") 
... 
>>> instance = Class() 
>>> instance.method() I have a self! 
>>> instance.method = function 
>>> instance.method() I don't...

>>> class Bird: 
... song = 'Squaawk!' 
... def sing(self): 
... print(self.song) 
... 
>>> bird = Bird() 
>>> bird.sing() 
Squaawk! 
>>> birdsong = bird.sing 
>>> birdsong() 
Squaawk!
```

#### 7.2.4 再谈隐藏

要让方法或属性成为私有的（不能从外部访问），只需让其名称以两个下划线打头即可

```python
class Secretive: 
    def __inaccessible(self): 
        print("Bet you can't see me ...") 
    def accessible(self): 
        print("The secret message is:") 
        self.__inaccessible()
```

```
>>> s = Secretive() 
>>> s.__inaccessible() 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
AttributeError: Secretive instance has no attribute '__inaccessible' 
>>> s.accessible() 
The secret message is: 
Bet you can't see me ...
```

#### 7.2.5 类的命名空间

在class语句中定义的代码都是在一个特殊的命名空间（类的命名空间）内执行的，而类的所有成员都可访问这个命名空间

#### 7.2.6 指定超类

```python
class Filter: 
    def init(self): 
        self.blocked = [] 
    def filter(self, sequence): 
        return [x for x in sequence if x not in self.blocked] 
class SPAMFilter(Filter): # SPAMFilter是Filter的子类
    def init(self): # 重写超类Filter的方法init 
        self.blocked = ['SPAM']
```

#### 7.2.7 深入探讨继承

要确定一个类是否是另一个类的子类，可使用内置方法issubclass

```
>>> issubclass(SPAMFilter, Filter) 
True 
>>> issubclass(Filter, SPAMFilter) 
False
```

如果你有一个类，并想知道它的基类，可访问其特殊属性__bases__

```
>>> SPAMFilter.__bases__ 
(<class __main__.Filter at 0x171e40>,) 
>>> Filter.__bases__ 
(<class 'object'>,)
```

同样，要确定对象是否是特定类的实例，可使用isinstance

```
>>> s = SPAMFilter() 
>>> isinstance(s, SPAMFilter) 
True 
>>> isinstance(s, Filter)
True 
>>> isinstance(s, str) 
False
```

如果你要获悉对象属于哪个类，可使用属性__class__。

```
>>> s.__class__ 
<class __main__.SPAMFilter at 0x1707c0>
```

#### 7.2.8 多个超类

```python
class Calculator: 
    def calculate(self, expression): 
    self.value = eval(expression) 
class Talker: 
    def talk(self): 
    print('Hi, my value is', self.value) 
class TalkingCalculator(Calculator, Talker): 
    pass
```

```
>>> tc = TalkingCalculator() 
>>> tc.calculate('1 + 2 * 3') 
>>> tc.talk() 
Hi, my value is 7
```

这被称为多重继承，是一个功能强大的工具。然而，除非万不得已，否则应避免使用多重继承，因为在有些情况下，它可能带来意外的“并发症

多个超类的超类相同时，查找特定方法或属性时访
问超类的顺序称为方法解析顺序（MRO），它使用的算法非常复杂

#### 7.2.9 接口和内省

通常，你要求对象遵循特定的接口（即实现特定的方法），但如果需要，也可非常灵活地提出要求：不是直接调用方法并期待一切顺利，而是检查所需的方法是否存在；如果不存在，就改弦易辙。

```
>>> hasattr(tc, 'talk') 
True 
>>> hasattr(tc, 'fnord') 
False
```

还可以检查属性talk是否是可调用的。

```
>>> callable(getattr(tc, 'talk', None)) 
True 
>>> callable(getattr(tc, 'fnord', None)) 
False
```

请注意，这里没有在if语句中使用hasattr并直接访问属性，而是使用了getattr（它让我能
够指定属性不存在时使用的默认值，这里为None），然后对返回的对象调用callable

#### 7.2.10 抽象基类

Python几乎都只依赖于鸭子类型，即假设所有对象都能完成其工作，同时偶尔使用hasattr来检查所需的方法是否存在
Python通过引入模块abc提供了官方解决方案

```python
from abc import ABC, abstractmethod 
class Talker(ABC): 
    @abstractmethod 
    def talk(self): 
    pass
```

形如@this的东西被称为装饰器

抽象类（即包含抽象方法的类）最重要的特征是不能实例化

```
>>> Talker() 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
TypeError: Can't instantiate abstract class Talker with abstract methods talk
```

可重新编写这个类，使其实现要求的方法

```python
class Knigget(Talker): 
    def talk(self): 
    print("Ni!")
```

```
>>> k = Knigget()
>>> isinstance(k, Talker) 
True 
>>> k.talk() 
Ni!
```

可将Herring注册为Talker（而不从Herring和Talker派生出子类），这样所有的Herring对象都将被视为Talker对象

```python
class Herring: 
    def talk(self): 
    print("Blub.")
```

```
>>> Talker.register(Herring) 
<class '__main__.Herring'> 
>>> isinstance(h, Talker) 
True 
>>> issubclass(Herring, Talker) 
True

>>> class Clam: 
... pass 
... 
>>> Talker.register(Clam) 
<class '__main__.Clam'> 
>>> issubclass(Clam, Talker) 
True 
>>> c = Clam() 
>>> isinstance(c, Talker) 
True 
>>> c.talk() 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
AttributeError: 'Clam' object has no attribute 'talk'
```

这种做法存在一个缺点，就是直接从抽象类派生提供的保障没有了

### 7.3 关于面向对象设计的一些思考

- 将相关的东西放在一起。如果一个函数操作一个全局变量，最好将它们作为一个类的属性和方法。
- 不要让对象之间过于亲密。方法应只关心其所属实例的属性，对于其他实例的状态，让它们自己去管理就好了。
- 慎用继承，尤其是多重继承。继承有时很有用，但在有些情况下可能带来不必要的复杂性。要正确地使用多重继承很难，要排除其中的bug更难。
- 保持简单。让方法短小紧凑。一般而言，应确保大多数方法都能在30秒内读完并理解。对于其余的方法，尽可能将其篇幅控制在一页或一屏内。

确定需要哪些类以及这些类应包含哪些方法时

1. 将有关问题的描述（程序需要做什么）记录下来，并给所有的名词、动词和形容词加上标记。
2. 在名词中找出可能的类。
3. 在动词中找出可能的方法。
4. 在形容词中找出可能的属性。
5. 将找出的方法和属性分配给各个类。

有了面向对象模型的草图后，还需考虑类和对象之间的关系（如继承或协作）以及它们的职责

1. 记录（或设想）一系列用例，即使用程序的场景，并尽力确保这些用例涵盖了所有的功能。
2. 透彻而仔细地考虑每个场景，确保模型包含了所需的一切。如果有遗漏，就加上；如果有不太对的地方，就修改。不断地重复这个过程，直到对模型满意为止。

### 7.4 小结

- **对象**：对象由属性和方法组成。属性不过是属于对象的变量，而方法是存储在属性中的函数。相比于其他函数，（关联的）方法有一个不同之处，那就是它总是将其所属的对象作为第一个参数，而这个参数通常被命名为self。
- **类**：类表示一组（或一类）对象，而每个对象都属于特定的类。类的主要任务是定义其实例将包含的方法。
- **多态**：多态指的是能够同样地对待不同类型和类的对象，即无需知道对象属于哪个类就可调用其方法。
- **封装**：对象可能隐藏（封装）其内部状态。在有些语言中，这意味着对象的状态（属性）只能通过其方法来访问。在Python中，所有的属性都是公有的，但直接访问对象的状态时程序员应谨慎行事，因为这可能在不经意间导致状态不一致。
- **继承**：一个类可以是一个或多个类的子类，在这种情况下，子类将继承超类的所有方法。你可指定多个超类，通过这样做可组合正交（独立且不相关）的功能。为此，一种常见的做法是使用一个核心超类以及一个或多个混合超类。
- **接口和内省**：一般而言，你无需过于深入地研究对象，而只依赖于多态来调用所需的方法。然而，如果要确定对象包含哪些方法或属性，有一些函数可供你用来完成这种工作。
- **抽象基类**：使用模块abc可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却不实现这些功能。
- **面向对象设计**：关于该如何进行面向对象设计以及是否该采用面向对象设计，有很多不同的观点。无论你持什么样的观点，都必须深入理解问题，进而创建出易于理解的设计。

#### 7.4.1 本章介绍的新函数


| 函 数                            | 描 述                                        |
| :------------------------------- | :------------------------------------------- |
| callable(object)                 | 判断对象是否是可调用的（如是否是函数或方法） |
| getattr(object,name\[,default\]) | 获取属性的值，还可提供默认值                 |
| hasattr(object, name)            | 确定对象是否有指定的属性                     |
| isinstance(object, class)        | 确定对象是否是指定类的实例                   |
| issubclass(A, B)                 | 确定A是否是B的子类                           |
| random.choice(sequence)          | 从一个非空序列中随机地选择一个元素           |
| setattr(object, name, value)     | 将对象的指定属性设置为指定的值               |
| type(object)                     | 返回对象的类型                               |

## 第8章 异常

### 8.1 异常是什么

Python使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕
获）时，程序将终止并显示一条错误消息（traceback）

```
>>> 1 / 0 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
ZeroDivisionError: integer division or modulo by zero
```

### 8.2 让事情沿你指定的轨道出错

#### 8.2.1 raise 语句

要引发异常，可使用raise语句，并将一个类（必须是Exception的子类）或实例作为参数。将类作为参数时，将自动创建一个实例
下面的示例使用的是内置异常类Exception

```
>>> raise Exception
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
Exception 

>>> raise Exception('hyperdrive overload') 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
Exception: hyperdrive overload
```

一些内置的异常类


| 类 名             | 描 述                                                            |
| :---------------- | :--------------------------------------------------------------- |
| Exception         | 几乎所有的异常类都是从它派生而来的                               |
| AttributeError    | 引用属性或给它赋值失败时引发                                     |
| OSError           | 操作系统不能执行指定的任务（如打开文件）时引发，有多个子类       |
| IndexError        | 使用序列中不存在的索引时引发，为LookupError的子类                |
| KeyError          | 使用映射中不存在的键时引发，为LookupError的子类                  |
| NameError         | 找不到名称（变量）时引发                                         |
| SyntaxError       | 代码不正确时引发                                                 |
| TypeError         | 将内置操作或函数用于类型不正确的对象时引发                       |
| ValueError        | 将内置操作或函数用于这样的对象时引发：其类型正确但包含的值不合适 |
| ZeroDivisionError | 在除法或求模运算的第二个参数为零时引发                           |

#### 8.2.2 自定义的异常类

```
class SomeCustomException(Exception): pass
```

### 8.3 捕获异常

异常比较有趣的地方是可对其进行处理，通常称之为捕获异常

```python
try: 
 x = int(input('Enter the first number: ')) 
 y = int(input('Enter the second number: ')) 
 print(x / y) 
except ZeroDivisionError: 
 print("The second number can't be zero!")
```

#### 8.3.1 不用提供参数

```python
class MuffledCalculator: 
    muffled = False 
    def calc(self, expr): 
        try: 
            return eval(expr) 
        except ZeroDivisionError: 
            if self.muffled: 
                print('Division by zero is illegal') 
            else: 
                raise
```

> 发生除零行为时，如果启用了“抑制”功能，方法calc将（隐式地）返回None。换而言之，如果启用了“抑制”功能，就不应依赖返回值。

```
>>> calculator = MuffledCalculator() 
>>> calculator.calc('10 / 2') 
5.0 

>>> calculator.calc('10 / 0') # 关闭了抑制功能
Traceback (most recent call last): File "<stdin>", line 1, in ? 
 File "MuffledCalculator.py", line 6, in calc 
 return eval(expr) 
 File "<string>", line 0, in ? 
ZeroDivisionError: integer division or modulo by zero
 
>>> calculator.muffled = True 
>>> calculator.calc('10 / 0') 
Division by zero is illegal
```

```
>>> try: 
... 1/0 
... except ZeroDivisionError: 
... raise ValueError 
... 
Traceback (most recent call last): 
 File "<stdin>", line 2, in <module> 
ZeroDivisionError: division by zero
Traceback (most recent call last): 
 File "<stdin>", line 4, in <module> 
ValueError

>>> try: 
... 1/0 
... except ZeroDivisionError: 
... raise ValueError from None 
... 
Traceback (most recent call last): 
 File "<stdin>", line 4, in <module> 
ValueError
```

#### 8.3.2 多个 except 子句

```python
try: 
 x = int(input('Enter the first number: ')) 
 y = int(input('Enter the second number: ')) 
 print(x / y) 
except ZeroDivisionError: 
 print("The second number can't be zero!") 
except TypeError: 
 print("That wasn't a number, was it?")
```

#### 8.3.3 一箭双雕

```python
try: 
 x = int(input('Enter the first number: ')) 
 y = int(input('Enter the second number: ')) 
 print(x / y) 
except (ZeroDivisionError, TypeError, NameError): 
 print('Your numbers were bogus ...')
```

#### 8.3.4 捕获对象

```python
try: 
 x = int(input('Enter the first number: ')) 
 y = int(input('Enter the second number: ')) 
 print(x / y) 
except (ZeroDivisionError, TypeError) as e: 
 print(e)
```

#### 8.3.5 一网打尽

例如，对于前面执行除法运算的程序，如果用户在提示时不输入任何内容就按回车键，将出现一条错误消息，还有一些相关问题出在什么地方的信息（栈跟踪）

```
Traceback (most recent call last): 
 ... 
ValueError: invalid literal for int() with base 10: ''
```

```python
try: 
 x = int(input('Enter the first number: ')) 
 y = int(input('Enter the second number: ')) 
 print(x / y) 
except: 
 print('Something wrong happened ...')
```

#### 8.3.6 万事大吉时

```python
try: 
    print('A simple task') 
except: 
    print('What? Something went wrong?') 
else: 
    print('Ah ... It went as planned.')
```

```python
while True: 
    try: 
        x = int(input('Enter the first number: ')) 
        y = int(input('Enter the second number: ')) 
        value = x / y 
        print('x / y is', value) 
    except: 
        print('Invalid input. Please try again.') 
    else: 
        break
```

下面是这些代码的运行情况

```
Enter the first number: 1 
Enter the second number: 0 
Invalid input. Please try again. 
Enter the first number: 'foo' 
Enter the second number: 'bar' 
Invalid input. Please try again. 
Enter the first number: baz 
Invalid input. Please try again. 
Enter the first number: 10 
Enter the second number: 2 
x / y is 5
```

```python
while True: 
    try: 
        x = int(input('Enter the first number: ')) 
        y = int(input('Enter the second number: ')) 
        value = x / y 
        print('x / y is', value) 
    except Exception as e: 
        print('Invalid input:', e) 
        print('Please try again') 
    else: 
        break
```

下面是这个程序的运行情况

```
Enter the first number: 1 
Enter the second number: 0 
Invalid input: integer division or modulo by zero 
Please try again 
Enter the first number: 'x' Enter the second number: 'y' 
Invalid input: unsupported operand type(s) for /: 'str' and 'str' 
Please try again 
Enter the first number: quuux 
Invalid input: name 'quuux' is not defined 
Please try again 
Enter the first number: 10 
Enter the second number: 2 
x / y is 5
```

#### 8.3.7 最后

```python
x = None 
try: 
    x = 1 / 0 
finally: 
    print('Cleaning up ...') 
    del x
```

在上述示例中，不管try子句中发生什么异常，都将执行finally子句
为何在try子句之前初始化x呢？因为如果不这样做，ZeroDivisionError将导致根本没有机会给它赋值，进而导致在finally子句中对其执行del时引发未捕获的异常。

```
Cleaning up ... 
Traceback (most recent call last): 
 File "C:\python\div.py", line 4, in ? 
 x = 1 / 0 
ZeroDivisionError: integer division or modulo by zero
```

```python
try: 
    1 / 0 
except NameError: 
    print("Unknown variable") 
else: 
    print("That went well!") 
finally: 
    print("Cleaning up.")
```

### 8.4 异常和函数

```
>>> def faulty(): 
... raise Exception('Something is wrong') 
... 
>>> def ignore_exception(): 
... faulty() 
... 
>>> def handle_exception(): 
... try: 
... faulty() 
... except: 
... print('Exception handled') 
... 
>>> ignore_exception() 
Traceback (most recent call last): 
 File '<stdin>', line 1, in ? 
 File '<stdin>', line 2, in ignore_exception 
 File '<stdin>', line 2, in faulty 
Exception: Something is wrong 
>>> handle_exception() 
Exception handled
```

如果不处理函数中引发的异常，它将向上传播到调用函数的地方。如果在那里也未得到处理，异常将继续传播，直至到达主程序（全局作用域）

### 8.5 异常之禅

```python
def describe_person(person): 
    print('Description of', person['name']) 
    print('Age:', person['age']) 
    try: 
        print('Occupation:', person['occupation']) 
    except KeyError: pass
  
try: 
    obj.write 
except AttributeError: 
    print('The object is not writeable') 
else: 
    print('The object is writeable')
```

### 8.6 不那么异常的情况

如果你只想发出警告，指出情况偏离了正轨，可使用模块warnings中的函数warn

```
>>> from warnings import warn 
>>> warn("I've got a bad feeling about this.") 
__main__:1: UserWarning: I've got a bad feeling about this. 
>>>

>>> from warnings import filterwarnings 
>>> filterwarnings("ignore") 
>>> warn("Anyone out there?") 
>>> filterwarnings("error") 
>>> warn("Something is very wrong!") 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
UserWarning: Something is very wrong!

>>> filterwarnings("error") 
>>> warn("This function is really old...", DeprecationWarning) 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
DeprecationWarning: This function is really old... 
>>> filterwarnings("ignore", category=DeprecationWarning) 
>>> warn("Another deprecation warning.", DeprecationWarning)
>>> warn("Something else.") 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
UserWarning: Something else.
```

### 8.7 小结

- 异常对象：异常情况（如发生错误）是用异常对象表示的。对于异常情况，有多种处理方式；如果忽略，将导致程序终止。
- 引发异常：可使用raise语句来引发异常。它将一个异常类或异常实例作为参数，但你也可提供两个参数（异常和错误消息）。如果在except子句中调用raise时没有提供任何参数，它将重新引发该子句捕获的异常。
- 自定义的异常类：你可通过从Exception派生来创建自定义的异常。
- 捕获异常：要捕获异常，可在try语句中使用except子句。在except子句中，如果没有指定异常类，将捕获所有的异常。你可指定多个异常类，方法是将它们放在元组中。如果向except提供两个参数，第二个参数将关联到异常对象。在同一条try/except语句中，可包含多个except子句，以便对不同的异常采取不同的措施。
- else子句：除except子句外，你还可使用else子句，它在主try块没有引发异常时执行。
- finally：要确保代码块（如清理代码）无论是否引发异常都将执行，可使用try/finally，并将代码块放在finally子句中。
- 异常和函数：在函数中引发异常时，异常将传播到调用函数的地方（对方法来说亦如此）。
- 警告：警告类似于异常，但（通常）只打印一条错误消息。你可指定警告类别，它们是Warning的子类。

#### 8.7.1 本章介绍的新函数


| 函 数                                                 | 描 述        |
| :---------------------------------------------------- | :----------- |
| warnings.filterwarnings(action,category=Warning, ...) | 用于过滤警告 |
| warnings.warn(message, category=None)                 | 用于发出警告 |

## 第9章 魔法方法、特性和迭代器

### 9.1 如果你使用的不是 Python 3(略)

```python
class NewStyle(object): 
    more_code_here
class OldStyle: 
    more_code_here
```

### 9.2 构造函数

构造函数不同于普通方法的地方在于，将在对象创建后自动调用它们

在Python中，创建构造函数很容易，只需将方法init的名称从普通的init改为魔法版__init__即可

```python
class FooBar: 
    def __init__(self): 
    self.somevar = 42
  
class FooBar: 
    def __init__(self, value=42): 
    self.somevar = value
```

```
>>> f = FooBar('This is a constructor argument') 
>>> f.somevar 
'This is a constructor argument'
```

> Python提供了魔法方法__del__，也称作析构函数（destructor）。这个方法在对象被销毁（作为垃圾被收集）前被调用，但鉴于你无法知道准确的调用时间，建议尽可能不要使用__del__。

#### 9.2.1 重写普通方法和特殊的构造函数

```python
class A: 
    def hello(self): 
    print("Hello, I'm A.") 
class B(A): 
    pass
```

```
>>> a = A() 
>>> b = B() 
>>> a.hello() 
Hello, I'm A. 

>>> b.hello() 
Hello, I'm A.
```

B可以重写方法hello

```python
class B(A): 
 def hello(self): 
 print("Hello, I'm B.")
```

```
>>> b = B() 
>>> b.hello() 
Hello, I'm B.
```

重写构造函数时，必须调用超类（继承的类）的构造函数，否则可能无法正确地初始化对象

```python
class Bird: 
    def __init__(self): 
        self.hungry = True 
    def eat(self):
        if self.hungry: 
            print('Aaaah ...') 
            self.hungry = False 
        else: 
            print('No, thanks!')
 
class SongBird(Bird): 
    def __init__(self): 
        self.sound = 'Squawk!' 
    def sing(self): 
        print(self.sound)
```

```
>>> sb = SongBird() 
>>> sb.sing() 
Squawk!

>>> sb.eat() 
Traceback (most recent call last): 
 File "<stdin>", line 1, in ? 
 File "birds.py", line 6, in eat 
 if self.hungry: 
AttributeError: SongBird instance has no attribute 'hungry'
```

异常清楚地指出了问题出在什么地方：SongBird没有属性hungry

#### 9.2.2 调用未关联的超类构造函数

```python
class SongBird(Bird): 
    def __init__(self): 
        Bird.__init__(self) 
        self.sound = 'Squawk!' 
    def sing(self): 
        print(self.sound)
```

```
>>> sb = SongBird() 
>>> sb.sing() 
Squawk! 
>>> sb.eat() 
Aaaah ... 
>>> sb.eat() 
No, thanks!
```

对实例调用方法时，方法的参数self将自动关联到实例

#### 9.2.3 使用函数 super

```python
class Bird: 
    def __init__(self): 
        self.hungry = True 
    def eat(self): 
        if self.hungry: 
            print('Aaaah ...') 
            self.hungry = False 
        else: 
            print('No, thanks!') 
class SongBird(Bird): 
    def __init__(self): 
        super().__init__()
        self.sound = 'Squawk!' 
    def sing(self): 
        print(self.sound)
```

```
>>> sb = SongBird() 
>>> sb.sing() 
Squawk! 
>>> sb.eat() 
Aaaah ... 
>>> sb.eat() 
No, thanks!
```

### 9.3 元素访问

#### 9.3.1 基本的序列和映射协议

- \_\_len__(self)：这个方法应返回集合包含的项数，对序列来说为元素个数，对映射来说为键-值对数。如果__len__返回零（且没有实现覆盖这种行为的__nonzero__），对象在布尔上下文中将被视为假（就像空的列表、元组、字符串和字典一样）。
- \_\_getitem__(self,
  key)：这个方法应返回与指定键相关联的值。对序列来说，键应该是0~n
  -1的整数（也可以是负数，这将在后面说明），其中n为序列的长度。对映射来说，键可以是任何类型。
- \_\_setitem__(self, key,
  value)：这个方法应以与键相关联的方式存储值，以便以后能够使用__getitem__来获取。当然，仅当对象可变时才需要实现这个方法。
- \_\_delitem__(self,
  key)：这个方法在对对象的组成部分使用__del__语句时被调用，应删除与key相关联的值。同样，仅当对象可变（且允许其项被删除）时，才需要实现这个方法。

对于这些方法，还有一些额外的要求。

- 对于序列，如果键为负整数，应从末尾往前数。换而言之，x\[-n\]应与x\[len(x)-n\]等效。
- 如果键的类型不合适（如对序列使用字符串键），可能引发TypeError异常。
- 对于序列，如果索引的类型是正确的，但不在允许的范围内，应引发IndexError异常。

创建一个无穷序列

```python
def check_index(key): 
    """ 
    指定的键是否是可接受的索引？
    键必须是非负整数，才是可接受的。如果不是整数，
    将引发TypeError异常；如果是负数，将引发Index 
    Error异常（因为这个序列的长度是无穷的）
    """ 
    if not isinstance(key, int): raise TypeError 
    if key < 0: raise IndexError 
class ArithmeticSequence: 
    def __init__(self, start=0, step=1): 
        """ 
        始化这个算术序列
        start -序列中的第一个值
        step -两个相邻值的差
        changed -一个字典，包含用户修改后的值
        """ 
        self.start = start # 存储起始值
        self.step = step # 存储步长值
        self.changed = {} # 没有任何元素被修改
    def __getitem__(self, key): 
        """ 
        算术序列中获取一个元素
        """ 
        check_index(key) 
        try: return self.changed[key] # 修改过？
        except KeyError: # 如果没有修改过，
            return self.start + key * self.step # 就计算元素的值
    def __setitem__(self, key, value): 
        """ 
        修改算术序列中的元素
        """ 
        check_index(key) 
        self.changed[key] = value # 存储修改后的值
```

#### 9.3.2 从 list、dict 和 str 派生

一个带访问计数器的列表

```python
class CounterList(list): 
    def __init__(self, *args): 
        super().__init__(*args) 
        self.counter = 0 
    def __getitem__(self, index): 
        self.counter += 1 
        return super(CounterList, self).__getitem__(index)
```

CounterList的行为在大多数方面都类似于列表，但它有一个counter属性

### 9.4 其他魔法方法

### 9.5 特性

```python
class Rectangle: 
    def __init__(self): 
        self.width = 0 
        self.height = 0 
    def set_size(self, size): 
        self.width, self.height = size 
    def get_size(self): 
        return self.width, self.height
```

```
>>> r = Rectangle() 
>>> r.width = 10 
>>> r.height = 5 
>>> r.get_size() 
(10, 5) 
>>> r.set_size((150, 100)) 
>>> r.width 
150
```

get_size和set_size是假想属性size的存取方法，这个属性是一个由width和height组成的元组

#### 9.5.1 函数 property

```python
class Rectangle: 
    def __init__ (self): 
        self.width = 0 
        self.height = 0 
    def set_size(self, size): 
        self.width, self.height = size 
    def get_size(self): 
        return self.width, self.height 
    size = property(get_size, set_size)
```

```
>>> r = Rectangle() 
>>> r.width = 10 
>>> r.height = 5 
>>> r.size 
(10, 5) 
>>> r.size = 150, 100 
>>> r.width 
150
```

如你所见，属性size依然受制于get_size和set_size执行的计算，但看起来就像普通属性一样

#### 9.5.2 静态方法和类方法

静态方法的定义中没有参数self，可直接通过类来调用
类方法的定义中包含类似于self的参数，通常被命名为cls.
对于类方法，也可通过对象直接调用，但参数cls将自动关联到类

```python
class MyClass: 
    def smeth():
        print('This is a static method') 
    smeth = staticmethod(smeth) 
  
    def cmeth(cls): 
        print('This is a class method of', cls) 
    cmeth = classmethod(cmeth)
```

```
>>> MyClass.smeth() 
This is a static method 
>>> MyClass.cmeth() 
This is a class method of <class '__main__.MyClass'>
```

#### 9.5.3 \_\_getattr\_\_、__setattr__等方法

- \_\_getattribute__(self, name)：在属性被访问时自动调用（只适用于新式类）。
- \_\_getattr__(self, name)：在属性被访问而对象没有这样的属性时自动调用。
- \_\_setattr__(self, name, value)：试图给属性赋值时自动调用。
- \_\_delattr__(self, name)：试图删除属性时自动调用。

```python
class Rectangle: 
    def __init__ (self): 
        self.width = 0 
        self.height = 0 
    def __setattr__(self, name, value): 
        if name == 'size': 
            self.width, self.height = value 
        else: 
            self. __dict__[name] = value 
    def __getattr__(self, name): 
        if name == 'size': 
            return self.width, self.height 
        else: 
            raise AttributeError()
```

- 即便涉及的属性不是size，也将调用方法__setattr__。因此这个方法必须考虑如下两种情形：如果涉及的属性为size，就执行与以前一样的操作；否则就使用魔法属性__dict__。/_/_dict__属性是一个字典，其中包含所有的实例属性。之所以使用它而不是执行常规属性赋值，是因为旨在避免再次调用__setattr__，进而导致无限循环。
- 仅当没有找到指定的属性时，才会调用方法__getattr__。这意味着如果指定的名称不是size，这个方法将引发AttributeError异常。这在要让类能够正确地支持hasattr和getattr等内置函数时很重要。如果指定的名称为size，就使用前一个实现中的表达式。

### 9.6 迭代器

介绍__iter__

#### 9.6.1 迭代器协议

迭代（iterate）意味着重复多次，就像循环那样

方法__iter__返回一个迭代器，它是包含方法__next__的对象，而调用这个方法时可不提供任何参数
当你调用方法__next__时，迭代器应返回其下一个值
如果迭代器没有可供返回的值，应引发StopIteration异常
你还可使用内置的便利函数next，在这种情况下，next(it)与it.__next__()等效

```python
class Fibs: 
    def __init__(self): 
        self.a = 0 
        self.b = 1 
    def __next__(self): 
        self.a, self.b = self.b, self.a + self.b 
        return self.a 
    def __iter__(self): 
        return self
```

注意到这个迭代器实现了方法__iter__，而这个方法返回迭代器本身。在很多情况下，都在另一个对象中实现返回迭代器的方法__iter__，并在for循环中使用这个对象。但推荐在迭代器中也实现方法__iter__（并像刚才那样让它返回self），这样迭代器就可直接用于for循环中

> 更正规的定义是，实现了方法__iter__的对象是可迭代的，而实现了方法__next__的对象是迭代器。

```python
fibs = Fibs()
for f in fibs: 
    if f > 1000: 
    print(f) 
    break
```

#### 9.6.2 从迭代器创建序列

```
>>> class TestIterator: 
... value = 0 
... def __next__(self): 
... self.value += 1 
... if self.value > 10: raise StopIteration 
... return self.value 
... def __iter__(self): 
... return self 
... 
>>> ti = TestIterator() 
>>> list(ti) 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### 9.7 生成器

生成器是一种使用普通函数语法定义的迭代器

#### 9.7.1 创建生成器

```python
def flatten(nested): 
    for sublist in nested: 
        for element in sublist: 
            yield element
```

```
>>> nested = [[1, 2], [3, 4], [5]] 
>>> for num in flatten(nested): 
... print(num) 
... 
1 
2 
3 
4 
5
>>> list(flatten(nested)) 
[1, 2, 3, 4, 5]
```

#### 9.7.2 递归式生成器

```python
def flatten(nested): 
    try: 
        for sublist in nested: 
            for element in flatten(sublist): 
                yield element 
    except TypeError: 
        yield nested
```

调用flatten时，有两种可能性（处理递归时都如此）：基线条件和递归条件
在基线条件下，要求这个函数展开单个元素（如一个数）。在这种情况下，for循环将引发TypeError异常（因为你试图迭代一个数），而这个生成器只生成一个元素。
然而，如果要展开的是一个列表（或其他任何可迭代对象），你就需要做些工作：遍历所有的子列表（其中有些可能并不是列表）并对它们调用flatten，然后使用另一个for循环生成展开后的子列表中的所有元素

```python
def flatten(nested): 
    try: 
        # 不迭代类似于字符串的对象：
        try: nested + '' 
        except TypeError: pass 
        else: raise TypeError 
        for sublist in nested:
            for element in flatten(sublist): 
                yield element 
    except TypeError: 
        yield nested
```

如果表达式nested +
''引发了TypeError异常，就忽略这种异常；如果没有引发TypeError异常，内部try语句中的else子句将引发TypeError异常，这样将在外部的excpet子句中原封不动地生成类似于字符串的对象

#### 9.7.3 通用生成器

生成器由两个单独的部分组成：生成器的函数和生成器的迭代器。
生成器的函数是由def语句定义的，其中包含yield。
生成器的迭代器是这个函数返回的结果。
用不太准确的话说，这两个实体通常被视为一个，通称为生成器

```
>>> def simple_generator(): 
 yield 1 
... 
>>> simple_generator 
<function simple_generator at 153b44> 
>>> simple_generator() 
<generator object at 1510b0>
```

#### 9.7.4 生成器的方法

- 外部世界：外部世界可访问生成器的方法send，这个方法类似于next，但接受一个参数（要发送的“消息”，可以是任何对象）。
- 生成器：在挂起的生成器内部，yield可能用作表达式而不是语句。换而言之，当生成器重新运行时，yield返回一个值——通过send从外部世界发送的值。如果使用的是next，yield将返回None。

请注意，仅当生成器被挂起（即遇到第一个yield）后，使用send（而不是next）才有意义。要在此之前向生成器提供信息，可使用生成器的函数的参数。

> 如果一定要在生成器刚启动时对其调用方法send，可向它传递参数None。

```python
def repeater(value): 
    while True: 
        new = (yield value) 
        if new is not None: value = new
```

```
>>> r = repeater(42) 
>>> next(r) 
42 
>>> r.send("Hello, world!") 
"Hello, world!"
```

注意到使用圆括号将yield表达式括起来了,
如果要以某种方式使用返回值，就不管三七二十一，将其用圆括号括起吧

- 方法throw：用于在生成器中（yield表达式处）引发异常，调用时可提供一个异常类型、一个可选值和一个traceback对象。
- 方法close：用于停止生成器，调用时无需提供任何参数

#### 9.7.5 模拟生成器

如果你使用的是较老的Python版本，就无法使用生成器。下面是一个简单的解决方案，让你能够使用普通函数模拟生成器

```python
def flatten(nested): 
    result = [] 
    try: 
        # 不迭代类似于字符串的对象：
        try: nested + '' 
        except TypeError: pass 
        else: raise TypeError 
        for sublist in nested: 
            for element in flatten(sublist): 
                result.append(element) 
    except TypeError: 
        result.append(nested) 
    return result
```

### 9.8 八皇后问题

#### 9.8.1 生成器的回溯

```python
for each possibility at level 1: 
    for each possibility at level 2: 
        ... 
            for each possibility at level n: 
                is it viable?
```

要直接使用for循环来实现，必须知道有多少层。如果无法知道，可使用递归

#### 9.8.2 问题

你需要将8个皇后放在棋盘上，条件是任何一个皇后都不能威胁其他皇后，即任何两个皇后都不能吃掉对方

#### 9.8.3 状态表示

可简单地使用元组（或列表）来表示可能的解（或其一部分），其中每个元素表示相应行中皇后所在的位置（即列）。因此，如果state\[0\]==3，就说明第1行的皇后放在第4列（还记得吧，我们从0开始计数）。在特定的递归层级（特定的行），你只知道上面各皇后的位置，因此状态元组的长度小于8（即皇后总数）

> 完全可以使用列表（而不是元组）来表示状态，具体使用哪个完全取决于你的喜好。一般而言，如果序列较小且是静态的，使用元组可能是不错的选择

#### 9.8.4 检测冲突

```python
def conflict(state, nextX): 
    nextY = len(state) 
    for i in range(nextY): 
        if abs(state[i] - nextX) in (0, nextY - i): 
            return True 
    return False
```

参数nextX表示下一个皇后的水平位置（x坐标，即列），而nextY为下一个皇后的垂直位置（y坐标，即行）。这个函数对既有的每个皇后执行简单的检查：如果下一个皇后与当前皇后的x坐标相同或在同一条对角线上，将发生冲突，因此返回True；如果没有发生冲突，就返回False

#### 9.8.5 基线条件

```python
def queens(num, state): 
    if len(state) == num-1: 
        for pos in range(num): 
            if not conflict(state, pos): 
                yield pos
```

这段代码的意思是，如果只剩下最后一个皇后没有放好，就遍历所有可能的位置，并返回那些不会引发冲突的位置

#### 9.8.6 递归条件

处理好基线条件后，可在递归条件中假设来自更低层级（编号更大的皇后）的结果都是正确的。因此，只需在函数queens的前述实现中给if语句添加一个else子句。

```python
else: 
    for pos in range(num): 
        if not conflict(state, pos): 
            for result in queens(num, state + (pos,)): 
                yield (pos,) + result
```

```python
def queens(num=8, state=()): 
    for pos in range(num): 
        if not conflict(state, pos): 
            if len(state) == num-1: 
                yield (pos,) 
            else: 
                for result in queens(num, state + (pos,)): 
                    yield (pos,) + result
```

```
>>> list(queens(3)) 
[] 
>>> list(queens(4)) 
[(1, 3, 0, 2), (2, 0, 3, 1)] 
>>> for solution in queens(8): 
... print solution 
... 
(0, 4, 7, 5, 2, 6, 1, 3) 
(0, 5, 7, 2, 6, 3, 1, 4) 
... 
(7, 2, 0, 5, 1, 4, 6, 3) 
(7, 3, 0, 2, 5, 1, 6, 4) 
>>>
```

#### 9.8.7 扫尾工作

```python
def prettyprint(solution): 
    def line(pos, length=len(solution)): 
        return '. ' * (pos) + 'X ' + '. ' * (length-pos-1) 
    for pos in solution: 
        print(line(pos))
```

```
>>> import random 
>>> prettyprint(random.choice(list(queens(8)))) 
. . . . . X . . 
. X . . . . . . 
. . . . . . X . 
X . . . . . . . 
. . . X . . . . 
. . . . . . . X 
. . . . X . . . 
. . X . . . . .
```

### 9.9 小结

- 新式类和旧式类：Python类的工作方式在不断变化。较新的Python
  2版本有两种类，其中旧式类正在快速退出舞台。新式类是Python
  2.2引入的，提供了一些额外的功能，如支持函数super和property，而旧式类不支持。要创建新式类，必须直接或间接地继承object或设置__metaclass__。
- 魔法方法：Python中有很多特殊方法，其名称以两个下划线开头和结尾。这些方法的功能各不相同，但大都由Python在特定情况下自动调用。例如__init__是在对象创建后调用的。
- 构造函数：很多面向对象语言中都有构造函数，对于你自己编写的每个类，都可能需要为它实现一个构造函数。构造函数名为__init__，在对象创建后被自动调用。
- 重写：类可重写其超类中定义的方法（以及其他任何属性），为此只需实现这些方法即可。要调用被重写的版本，可直接通过超类调用未关联版本（旧式类），也可使用函数super来调用（新式类）。
- 序列和映射：要创建自定义的序列或映射，必须实现序列和映射协议指定的所有方法，其中包括__getitem__和__setitem__等魔法方法。通过从list（或UserList）和dict（或UserDict）派生，可减少很多工作量。
- 迭代器：简单地说，迭代器是包含方法__next__的对象，可用于迭代一组值。没有更多的值可供迭代时，方法__next__应引发StopIteration异常。可迭代对象包含方法__iter__，它返回一个像序列一样可用于for循环中的迭代器。通常，迭代器也是可迭代的，即包含返回迭代器本身的方法__iter__。
- 生成器：生成器的函数是包含关键字yield的函数，它在被调用时返回一个生成器，即一种特殊的迭代器。要与活动的生成器交互，可使用方法send、throw和close。
- 八皇后问题：八皇后问题是个著名的计算机科学问题，使用生成器可轻松地解决它。这个问题要求在棋盘上放置8个皇后，并确保任何两个皇后都不能相互攻击。

#### 9.9.1 本章介绍的新函数


| 函 数                           | 描 述                            |
| :------------------------------ | :------------------------------- |
| iter(obj)                       | 从可迭代对象创建一个迭代器       |
| next(it)                        | 让迭代器前进一步并返回下一个元素 |
| property(fget, fset, fdel, doc) | 返回一个特性；所有参数都是可选的 |
| super(class, obj)               | 返回一个超类的关联实例           |

## 第10章 开箱即用

### 10.1 模块

```
>>> import math 
>>> math.sin(0) 
0.0
```

#### 10.1.1 模块就是程序

要告诉解释器去哪里查找这个模块，可执行如下命令

```
>>> import sys 
>>> sys.path.append('C:/python')
```

> 在UNIX中，不能直接将字符串'~/python'附加到sys.path末尾，而必须使用完整的路径（如'/home/yourusername/python'）。如果你要自动创建完整的路径，可使用sys.path.
> expanduser('~/python')。

因为模块并不是用来执行操作（如打印文本）的，而是用于定义变量、函数、类等。鉴于定义只需做一次，因此导入模块多次和导入一次的效果相同

#### 10.1.2 模块是用来下定义的

1. 在模块中定义函数

    代码清单10-2 只包含一个函数的简单模块

    ```python
    # hello2.py 
    def hello(): 
        print("Hello, world!")
    ```

    ```
    >>> import hello2

    >>> hello2.hello() 
    Hello, world!
    ```

    主要是为了重用代码。通过将代码放在模块中，就可在多个程序中使用它们

2. 在模块中添加测试代码

    代码清单10-3 一个简单的模块，其中的测试代码有问题

    ```python
    # hello3.py 
    def hello(): 
        print("Hello, world!") 
    
    # 一个测试：
    hello()
    ```

    ```
    >>> import hello3 
    Hello, world!   # 不应该出现
    >>> hello3.hello() 
    Hello, world!

    >>> __name__ 
    '__main__' 
    >>> hello3.__name__ 
    'hello3'
    ```

    在主程序中（包括解释器的交互式提示符），变量__name__的值是'__main__'，而在导入的模块中，这个变量被设置为该模块的名称。因此，要让模块中测试代码的行  为更合理，可将其放在一条if语句中

    代码清单10-4 一个包含有条件地执行的测试代码的模块

    ```python
    # hello4.py 
    def hello(): 
        print("Hello, world!") 
    def test(): 
        hello() 
    if __name__ == '__main__': test()
    ```

    ```
    >>> import hello4 
    >>> hello4.hello() 
    Hello, world!

    >>> hello4.test() 
    Hello, world!
    ```

#### 10.1.3 让模块可用

1. 将模块放在正确的位置

    可在模块sys的变量path中找到目录列表（即搜索路径）

    ```
    >>> import sys, pprint 
    >>> pprint.pprint(sys.path) 
    ['C:\\Python35\\Lib\\idlelib', 
     'C:\\Python35', 
     'C:\\Python35\\DLLs', 
     'C:\\Python35\\lib', 
     'C:\\Python35\\lib\\plat-win', 
     'C:\\Python35\\lib\\lib-tk', 
     'C:\\Python35\\lib\\site-packages']
    ```

    > 如果要打印的数据结构太大，一行容纳不下，可使用模块pprint中的函数pprint（而不是普通print语句）。pprint是个卓越的打印函数，能够更妥善地打印输出

    目录site-packages是最佳的选择，因为它就是用来放置模块的

2. 告诉解释器到哪里去查找

    将模块放在正确的位置可能不是合适的解决方案，其中的原因很多

    - 不希望Python解释器的目录中充斥着你编写的模块。
    - 没有必要的权限，无法将文件保存到Python解释器的目录中。
    - 想将模块放在其他地方。

    要告诉解释器到哪里去查找模块，办法之一是直接修改sys.path，但这种做法不常见。标准做法是将模块所在的目录包含在环境变量PYTHONPATH中

    环境变量PYTHONPATH的内容随操作系统而异（参见旁注“环境变量”），但它基本上类似于sys.path，也是一个目录列表

#### 10.1.4 包

为组织模块，可将其编组为包（package）。
包其实就是另一种模块，但有趣的是它们可包含其他模块。
模块存储在扩展名为.py的文件中，而包则是一个目录。

表10-1 一种简单的包布局


| 文件/目录                    | 描 述                 |
| :--------------------------- | :-------------------- |
| ~/python/                    | PYTHONPATH中的目录    |
| ~/python/drawing/            | 包目录（包drawing）   |
| ~/python/drawing/__init__.py | 包代码（模块drawing） |
| ~/python/drawing/colors.py   | 模块colors            |
| ~/python/drawing/shapes.py   | 模块shapes            |

```python
import drawing # (1) 导入drawing包
import drawing.colors # (2) 导入drawing包中的模块colors 
from drawing import shapes # (3) 导入模块shapes
```

### 10.2 探索模块

#### 10.2.1 模块包含什么

1. 使用dir

    要查明模块包含哪些东西，可使用函数dir，它列出对象的所有属性（对于模块，它列出所有的函数、类、变量等）

    如果将dir(copy)的结果打印出来，将是一个很长的名称列表（请试试看）

    在这些名称中，有几个以下划线打头根据约定，这意味着它们并非供外部使用

    ```
    >>> [n for n in dir(copy) if not n.startswith('_')] 
    ['Error', 'PyStringMap', 'copy', 'deepcopy', 'dispatch_table', 'error', 'name', 't', 'weakref']
    ```

    结果包含dir(copy)返回的不以下划线打头的名称，这比完整清单要好懂些

2. 变量__all__

    ```
    >>> copy.__all__ 
    ['Error', 'copy', 'deepcopy']
    ```

    旨在定义模块的公有接口

    ```
    from copy import *
    ```

    将只能得到变量__all__中列出的3个函数

    要导入PyStringMap，必须显式地：导入copy并使用copy.PyStringMap；或者使用from
    copy import PyStringMap

#### 10.2.2 使用 help 获取帮助

有一个标准函数可提供你通常需要的所有信息，它就是help

```
>>> help(copy.copy) 
Help on function copy in module copy: 
copy(x) 
 Shallow copy operation on arbitrary Python objects. 
 See the module's __doc__ string for more info.
 
>>> print(copy.copy.__doc__) 
Shallow copy operation on arbitrary Python objects. 
 See the module's __doc__ string for more info.
```

相比于直接查看文档字符串，使用help的优点是可获取更多的信息，如函数的特征标（即它接受的参数）

#### 10.2.3 文档

与其在Python图书或标准Python文档中查找对range的描述，不如直接检查这个函数

```
>>> print(range.__doc__) 
range(stop) -> range object 
range(start, stop[, step]) -> range object 
Return an object that produces a sequence of integers from start (inclusive) 
to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. 
start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. 
These are exactly the valid indices for a list of 4 elements. 
When step is given, it specifies the increment (or decrement).
```

#### 10.2.4 使用源代码

一种办法是像解释器那样通过sys.path来查找，但更快捷的方式是查看模块的特性__file__

```
>>> print(copy.__file__) 
C:\Python35\lib\copy.py
```

> 在文本编辑器中打开标准库文件时，存在不小心修改它的风险。这可能会破坏文件。因此关闭文件时，千万不要保存你可能对其所做的修改。

### 10.3 标准库：一些深受欢迎的模块

#### 10.3.1 sys

模块sys让你能够访问与Python解释器紧密相关的变量和函数

表10-2 模块sys中一些重要的函数和变量


| 函数/变量     | 描 述                                            |
| :------------ | :----------------------------------------------- |
| argv          | 命令行参数，包括脚本名                           |
| exit(\[arg\]) | 退出当前程序，可通过可选参数指定返回值或错误消息 |
| modules       | 一个字典，将模块名映射到加载的模块               |
| path          | 一个列表，包含要在其中查找模块的目录的名称       |
| platform      | 一个平台标识符，如sunos5或win32                  |
| stdin         | 标准输入流——一个类似于文件的对象                 |
| stdout        | 标准输出流——一个类似于文件的对象                 |
| stderr        | 标准错误流——一个类似于文件的对象                 |

- 变量sys.argv包含传递给Python解释器的参数，其中包括脚本名
- 函数sys.exit退出当前程序你可向它提供一个整数，指出程序是否成功，这是一种UNIX约定。在大多数情况下，使用该参数的默认值（0，表示成功）即可。也可向它提供一个字符串，这个字符串将成为错误消息，对用户找出程序终止的原因很有帮助。在这种情况下，程序退出时将显示指定的错误消息以及一个表示失败的编码
- 映射sys.modules将模块名映射到模块（仅限于当前已导入的模块）。
- 变量sys.path在本章前面讨论过，它是一个字符串列表，其中的每个字符串都是一个目录名，执行import语句时将在这些目录中查找模块。
- 变量sys.platform（一个字符串）是运行解释器的“平台”名称。这可能是表示操作系统的名称（如sunos5或win32），也可能是表示其他平台类型（如Java虚拟机）的名称（如java1.4.0）——如果你运行的是Jython。
- 变量sys.stdin、sys.stdout和sys.stderr是类似于文件的流对象，表示标准的UNIX概念：标准输入、标准输出和标准错误。简单地说，Python从sys.stdin获取输入（例如，用于input中），并将输出打印到sys.stdout。

#### 10.3.2 os

表10-3 模块os中一些重要的函数和变量


| 函数/变量       | 描 述                          |
| :-------------- | :----------------------------- |
| environ         | 包含环境变量的映射             |
| system(command) | 在子shell中执行操作系统命令    |
| sep             | 路径中使用的分隔符             |
| pathsep         | 分隔不同路径的分隔符           |
| linesep         | 行分隔符（'\n'、'\r'或'\r\n'） |
| urandom(n)      | 返回n个字节的强加密随机数据    |

- 映射os.environ包含本章前面介绍的环境变量。例如，要访问环境变量PYTHONPATH，可使用表达式os.environ\['PYTHONPATH'\]。这个映射也可用于修改环境变量，但并非所有的平台都支持这样做。
- 函数os.system用于运行外部程序。还有其他用于执行外部程序的函数，如execv和popen。前者退出Python解释器，并将控制权交给被执行的程序，而后者创建一个到程序的连接（这个连接类似于文件）。
- 变量os.sep是用于路径名中的分隔符。在UNIX（以及macOS的命令行Python版本）中，标准分隔符为/。在Windows中，标准分隔符为\\（这种Python语法表示单个反斜杠）。在旧式macOS中，标准分隔符为:。（在有些平台中，os.altsep包含替代路径分隔符，如Windows中的/。）
- 可使用os.pathsep来组合多条路径，就像PYTHONPATH中那样。pathsep用于分隔不同的路径名：在UNIX/macOS中为:，而在Windows中为;。
- 变量os.linesep是用于文本文件中的行分隔符：在UNIX/OS
  X中为单个换行符（\n），在Windows中为回车和换行符（\r\n）。
- 函数urandom使用随系统而异的“真正”（至少是强加密）随机源。如果平台没有提供这样的随机源，将引发NotImplementedError异常

#### 10.3.3 fileinput

表10-4 模块fileinput中一些重要的函数


| 函 数                                     | 描 述                          |
| :---------------------------------------- | :----------------------------- |
| input(\[files\[, inplace\[, backup\]\]\]) | 帮助迭代多个输入流中的行       |
| filename()                                | 返回当前文件的名称             |
| lineno()                                  | 返回（累计的）当前行号         |
| filelineno()                              | 返回在当前文件中的行号         |
| isfirstline()                             | 检查当前行是否是文件中的第一行 |
| isstdin()                                 | 检查最后一行是否来自sys.stdin  |
| nextfile()                                | 关闭当前文件并移到下一个文件   |
| close()                                   | 关闭序列                       |

- fileinput.input是其中最重要的函数，它返回一个可在for循环中进行迭代的对象。如果要覆盖默认行为（确定要迭代哪些文件），可以序列的方式向这个函数提供一个或多个文件名。还可将参数inplace设置为True（inplace=True），这样将就地进行处理。对于你访问的每一行，都需打印出替代内容，这些内容将被写回到当前输入文件中。就地进行处理时，可选参数backup用于给从原始文件创建的备份文件指定扩展名。
- 函数fileinput.filename返回当前文件（即当前处理的行所属文件）的文件名。
- 函数fileinput.lineno返回当前行的编号。这个值是累计的，因此处理完一个文件并接着处理下一个文件时，不会重置行号，而是从前一个文件最后一行的行号加1开始。
- 函数fileinput.filelineno返回当前行在当前文件中的行号。每次处理完一个文件并接着处理下一个文件时，将重置这个行号并从1重新开始。
- 函数fileinput.isfirstline在当前行为当前文件中的第一行时返回True，否则返回False。
- 函数fileinput.isstdin在当前文件为sys.stdin时返回True，否则返回False。
- 函数fileinput.nextfile关闭当前文件并跳到下一个文件，且计数时忽略跳过的行。这在你知道无需继续处理当前文件时很有用。例如，如果每个文件包含的单词都是按顺序排列的，而你要查找特定的单词，则过了这个单词所在的位置后，就可放心地跳到下一个文件。
- 函数fileinput.close关闭整个文件链并结束迭代

```python
# numberlines.py 
import fileinput 
for line in fileinput.input(inplace=True): 
    line = line.rstrip() 
    num = fileinput.lineno() 
     print('{:<50} # {:2d}'.format(line, num))
```

```python
# numberlines.py                                # 1 
                                                # 2 
import fileinput                                # 3 
                                                # 4 
for line in fileinput.input(inplace=True):      # 5 
    line = line.rstrip()                        # 6 
    num = fileinput.lineno()                    # 7 
    print('{:<50} # {:2d}'.format(line, num))   # 8
```

> 务必慎用参数inplace，因为这很容易破坏文件。你应在不设置inplace的情况下仔细测试程序（这样将只打印结果），确保程序能够正确运行后再让它修改文件。

#### 10.3.4 集合、堆和双端队列

1. 集合

    在较新的版本中，集合是由内置类set实现的，这意味着你可直接创建集合，而无需导入模块sets。

    ```
    >>> set(range(10)) 
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    >>> type({}) 
    <class 'dict'>

    >>> {0, 1, 2, 3, 0, 1, 2, 3, 4, 5} 
    {0, 1, 2, 3, 4, 5}

    >>> {'fee', 'fie', 'foe'} 
    {'foe', 'fee', 'fie'}

    >>> a = {1, 2, 3} 
    >>> b = {2, 3, 4} 
    >>> a.union(b) 
    {1, 2, 3, 4} 
    >>> a | b 
    {1, 2, 3, 4}

    >>> c = a & b 
    >>> c.issubset(a) 
    True 
    >>> c <= a 
    True 
    >>> c.issuperset(a) 
    False 
    >>> c >= a 
    False 
    >>> a.intersection(b) 
    {2, 3} 
    >>> a & b 
    {2, 3} 
    >>> a.difference(b) 
    {1} 
    >>> a - b 
    {1} 
    >>> a.symmetric_difference(b) 
    {1, 4} 
    >>> a ^ b 
    {1, 4} 
    >>> a.copy()
    {1, 2, 3} 
    >>> a.copy() is a 
    False
    ```

    有frozenset类型，它表示不可变（可散列）的集合

    ```
    >>> a = set() 
    >>> b = set() 
    >>> a.add(b) 
    Traceback (most recent call last): 
     File "<stdin>", line 1, in ? 
    TypeError: set objects are unhashable 
    >>> a.add(frozenset(b))
    ```

2. 堆

    另一种著名的数据结构是堆（heap），它是一种优先队列。优先队列让你能够以任意顺序添加对象，并随时（可能是在两次添加对象之间）找出（并删除）最小的元素。    相比于列表方法min，这样做的效率要高得多

    表10-5 模块heapq中一些重要的函数


    | 函 数                | 描 述                         |
    | :------------------- | :---------------------------- |
    | heappush(heap, x)    | 将x压入堆中                   |
    | heappop(heap)        | 从堆中弹出最小的元素          |
    | heapify(heap)        | 让列表具备堆特征              |
    | heapreplace(heap, x) | 弹出最小的元素，并将x压入堆中 |
    | nlargest(n, iter)    | 返回iter中n个最大的元素       |
    | nsmallest(n, iter)   | 返回iter中n个最小的元素       |

    ```
    >>> from heapq import * 
    >>> from random import shuffle 
    >>> data = list(range(10)) 
    >>> shuffle(data) 
    >>> heap = [] 
    >>> for n in data: 
    ... heappush(heap, n) 
    ... 
    >>> heap 
    [0, 1, 3, 6, 2, 8, 4, 7, 9, 5] 
    >>> heappush(heap, 0.5) 
    >>> heap 
    [0, 0.5, 3, 6, 1, 8, 4, 7, 9, 5, 2]
    ```

    位置i处的元素总是大于位置i // 2处的元素（反过来说就是小于位置2 * i和2 * i
    +1处的元素）
    这是底层堆算法的基础，称为堆特征（heap property）。

    ```
    >>> heappop(heap) 
    0 
    >>> heappop(heap) 
    0.5 
    >>> heappop(heap) 
    1 
    >>> heap 
    [2, 5, 3, 6, 9, 8, 4, 7]

    >>> heap = [5, 8, 0, 3, 6, 7, 9, 1, 4, 2] 
    >>> heapify(heap) 
    >>> heap 
    [0, 1, 5, 3, 2, 7, 9, 8, 4, 6]

    >>> heapreplace(heap, 0.5) 
    0 
    >>> heap 
    [0.5, 1, 5, 3, 2, 7, 9, 8, 4, 6] 
    >>> heapreplace(heap, 10) 
    0.5 
    >>> heap 
    [1, 2, 5, 3, 6, 7, 9, 8, 4, 10]
    ```

3. 双端队列（及其他集合）

    在需要按添加元素的顺序进行删除时，双端队列很有用。在模块collections中，包含类型deque以及其他几个集合（collection）类型。

    ```
    >>> from collections import deque 
    >>> q = deque(range(5)) 
    >>> q.append(5) 
    >>> q.appendleft(6) 
    >>> q 
    deque([6, 0, 1, 2, 3, 4, 5]) 
    >>> q.pop() 
    5 
    >>> q.popleft() 
    6 
    >>> q.rotate(3) 
    >>> q 
    deque([2, 3, 4, 0, 1]) 
    >>> q.rotate(-1) 
    >>> q 
    deque([3, 4, 0, 1, 2])
    ```

#### 10.3.5 time

表10-6 Python日期元组中的字段


| 索 引 | 字 段  | 值                       |
| :---- | :----- | :----------------------- |
| 0     | 年     | 如2000、2001等           |
| 1     | 月     | 范围1~12                 |
| 2     | 日     | 范围1~31                 |
| 3     | 时     | 范围0~23                 |
| 4     | 分     | 范围0~59                 |
| 5     | 秒     | 范围0~61                 |
| 6     | 星期   | 范围0~6，其中0表示星期一 |
| 7     | 儒略日 | 范围1~366                |
| 8     | 夏令时 | 0、1或-1                 |

表10-7 模块time中一些重要的函数


| 函 数                        | 描 述                                       |
| :--------------------------- | :------------------------------------------ |
| asctime(\[tuple\])           | 将时间元组转换为字符串                      |
| localtime(\[secs\])          | 将秒数转换为表示当地时间的日期元组          |
| mktime(tuple)                | 将时间元组转换为当地时间                    |
| sleep(secs)                  | 休眠（什么都不做）secs秒                    |
| strptime(string\[, format\]) | 将字符串转换为时间元组                      |
| time()                       | 当前时间（从新纪元开始后的秒数，以UTC为准） |

- 函数time.asctime将当前时间转换为字符串，如下所示：

  ```
  >>> time.asctime() 
  'Mon Jul 18 14:06:07 2016'
  ```

  如果不想使用当前时间，也可向它提供一个日期元组（如localtime创建的日期元组）。要设置更复杂的格式，可使用函数strftime，标准文档对此做了介绍。
- 函数time.localtime将一个实数（从新纪元开始后的秒数）转换为日期元组（本地时间）。如果要转换为国际标准时间，应使用gmtime。
- 函数time.mktime将日期元组转换为从新纪元后的秒数，这与localtime的功能相反。
- 函数time.sleep让解释器等待指定的秒数。
- 函数time.strptime将一个字符串（其格式与asctime所返回字符串的格式相同）转换为日期元组。（可选参数format遵循的规则与strftime相同，详情请参阅标准文档。）
- 函数time.time返回当前的国际标准时间，以从新纪元开始的秒数表示。虽然新纪元随平台而异，但可这样进行可靠的计时：存储事件（如函数调用）发生前后time的结果，再计算它们的差。

#### 10.3.6 random

表10-8 模块random中一些重要的函数


| 函 数                                | 描 述                                        |
| :----------------------------------- | :------------------------------------------- |
| random()                             | 返回一个0~1（含）的随机实数                  |
| getrandbits(n)                       | 以长整数方式返回n个随机的二进制位            |
| uniform(a, b)                        | 返回一个a~b（含）的随机实数                  |
| randrange(\[start\], stop, \[step\]) | 从range(start, stop, step)中随机地选择一个数 |
| choice(seq)                          | 从序列seq中随机地选择一个元素                |
| shuffle(seq\[, random\])             | 就地打乱序列seq                              |
| sample(seq, n)                       | 从序列seq中随机地选择n个值不同的元素         |

- 函数random.random是最基本的随机函数之一，它返回一个0~1（含）的伪随机数。除非这正是你需要的，否则可能应使用其他提供了额外功能的函数。函数random.getrandbits以一个整数的方式返回指定数量的二进制位。
- 向函数random.uniform提供了两个数字参数a和b时，它返回一个a~b（含）的随机（均匀分布的）实数。例如，如果你需要一个随机角度，可使用uniform(0,
  360)。
- 函数random.randrange是生成随机整数的标准函数。为指定这个随机整数所在的范围，你可像调用range那样给这个函数提供参数。例如，要生成一个1~10（含）的随机整数，可使用randrange(1,
  11)或randrange(10) + 1。要生成一个小于20的随机正奇数，可使用randrange(1,20,
  2)。
- 函数random.choice从给定序列中随机（均匀）地选择一个元素。
- 函数random.shuffle随机地打乱一个可变序列中的元素，并确保每种可能的排列顺序出现的概率相同。
- 函数random.sample从给定序列中随机（均匀）地选择指定数量的元素，并确保所选择元素的值各不相同

```
from random import * 
from time import * 
date1 = (2016, 1, 1, 0, 0, 0, -1, -1, -1) 
time1 = mktime(date1) 
date2 = (2017, 1, 1, 0, 0, 0, -1, -1, -1) 
time2 = mktime(date2)

>>> random_time = uniform(time1, time2)

>>> print(asctime(localtime(random_time)))
Tue Aug 16 10:11:04 2016

from random import randrange 
num = int(input('How many dice? ')) 
sides = int(input('How many sides per die? ')) 
sum = 0 
for i in range(num): sum += randrange(sides) + 1 
print('The result is', sum)

How many dice? 3 
How many sides per die? 6 
The result is 10

# fortune.py 
import fileinput, random 
fortunes = list(fileinput.input()) 
print random.choice(fortunes)

$ python fortune.py /usr/share/dict/words 
dodge

>>> values = list(range(1, 11)) + 'Jack Queen King'.split() 
>>> suits = 'diamonds clubs hearts spades'.split() 
>>> deck = ['{} of {}'.format(v, s) for v in values for s in suits]

>>> from pprint import pprint 
>>> pprint(deck[:12]) 
['1 of diamonds', 
 '1 of clubs', 
 '1 of hearts', 
 '1 of spades', 
 '2 of diamonds', 
 '2 of clubs', 
 '2 of hearts', 
 '2 of spades', 
 '3 of diamonds', 
 '3 of clubs', 
 '3 of hearts', 
 '3 of spades']
 
>>> from random import shuffle 
>>> shuffle(deck) 
>>> pprint(deck[:12]) 
['3 of spades', 
 '2 of diamonds', 
 '5 of diamonds', 
 '6 of spades', 
 '8 of diamonds', 
 '1 of clubs', 
 '5 of hearts', 
 'Queen of diamonds', 
 'Queen of hearts', 
 'King of hearts', 
 'Jack of diamonds', 
 'Queen of clubs']
```

#### 10.3.7 shelve 和 json

如果需要的是简单的存储方案，模块shelve可替你完成大部分工作——你只需提供一个文件名即可对于模块shelve，你唯一感兴趣的是函数open。这个函数将一个文件名作为参数，并返回一个Shelf对象，供你用来存储数据。你可像操作普通字典那样操作它（只是键必须为字符串），操作完毕（并将所做的修改存盘）时，可调用其方法close。

1. 一个潜在的陷阱

   ```
   >>> import shelve 
   >>> s = shelve.open('test.dat') 
   >>> s['x'] = ['a', 'b', 'c'] 
   >>> s['x'].append('d') 
   >>> s['x'] 
   ['a', 'b', 'c']
   ```

   - 列表\['a', 'b', 'c'\]被存储到s的'x'键下。
   - 获取存储的表示，并使用它创建一个新列表，再将'd'附加到这个新列表末尾，但这个修改后的版本未被存储！
   - 最后，再次获取原来的版本——其中没有'd'。

   ```
   >>> temp = s['x'] 
   >>> temp.append('d') 
   >>> s['x'] = temp 
   >>> s['x'] 
   ['a', 'b', 'c', 'd']
   ```
2. 一个简单的数据库示例

   ```python
   # database.py 
   import sys, shelve 
   def store_person(db): 
       """ 
       让用户输入数据并将其存储到shelf对象中
       """ 
       pid = input('Enter unique ID number: ') 
       person = {} 
       person['name'] = input('Enter name: ') 
       person['age'] = input('Enter age: ') 
       person['phone'] = input('Enter phone number: ') 
       db[pid] = person 
   def lookup_person(db): 
       """ 
       让用户输入ID和所需的字段，并从shelf对象中获取相应的数据
       """ 
       pid = input('Enter ID number: ') 
       field = input('What would you like to know? (name, age, phone) ') 
       field = field.strip().lower() 
       print(field.capitalize() + ':', db[pid][field]) 
   def print_help(): 
       print('The available commands are:') 
       print('store : Stores information about a person') 
       print('lookup : Looks up a person from ID number') 
       print('quit : Save changes and exit') 
       print('? : Prints this message') 
   def enter_command(): 
       cmd = input('Enter command (? for help): ') 
       cmd = cmd.strip().lower() 
       return cmd 
   def main(): 
       database = shelve.open('C:\\database.dat') # 你可能想修改这个名称
       try: 
           while True: 
               cmd = enter_command() 
               if cmd == 'store': 
                   store_person(database) 
               elif cmd == 'lookup': 
                   lookup_person(database) 
               elif cmd == '?': 
                   print_help() 
               elif cmd == 'quit': 
                   return
           finally: 
               database.close()
       if name == '__main__': main()
   ```

   - 所有代码都放在函数中，这提高了程序的结构化程度（一个可能的改进是将这些函数作为一个类的方法）。
   - 主程序位于函数main中，这个函数仅在__name__==
     '__main__'时才会被调用。这意味着可在另一个程序中将这个程序作为模块导入，再调用函数main。
   - 在函数main中，我打开一个数据库（shelf），再将其作为参数传递给其他需要它的函数。由于这个程序很小，我原本可以使用一个全局变量，但在大多数情况下，最好不要使用全局变量——除非你有理由这样做。
   - 读入一些值后，我调用strip和lower来修改它们，因为仅当提供的键与存储的键完全相同时，它们才匹配。如果对用户输入的内容都调用strip和lower，用户输入时就无需太关心大小写，且在输入开头和末尾有多余的空白也没有关系。另外，注意到打印字段名时使用了capitalize。
   - 为确保数据库得以妥善的关闭，我使用了try和finally。不知道什么时候就会出现问题，进而引发异常。如果程序终止时未妥善地关闭数据库，数据库文件可能受损，变得毫无用处。通过使用try和finally，可避免这样的情况发生。我原本也可像第11章介绍的那样，将shelf用作上下文管理器。

   ```
   Enter command (? for help): ? 
   The available commands are: 
   store : Stores information about a person 
   lookup : Looks up a person from ID number 
   quit : Save changes and exit 
   ? : Prints this message 
   Enter command (? for help): store 
   Enter unique ID number: 001 
   Enter name: Mr. Gumby 
   Enter age: 42 
   Enter phone number: 555-1234 
   Enter command (? for help): lookup 
   Enter ID number: 001 
   What would you like to know? (name, age, phone) phone 
   Phone: 555-1234 
   Enter command (? for help): quit

   Enter command (? for help): lookup 
   Enter ID number: 001
   What would you like to know? (name, age, phone) name 
   Name: Mr. Gumby 
   Enter command (? for help): quit
   ```

#### 10.3.8 re

1. 正则表达式是什么

   正则表达式是可匹配文本片段的模式。最简单的正则表达式为普通字符串，与它自己匹配。换而言之，正则表达式'python'与字符串'python'匹配

   你可使用这种匹配行为来完成如下工作：
   在文本中查找模式，将特定的模式替换为计算得到的值，以及将文本分割成片段

   - 通配符
     - 正则表达式可与多个字符串匹配，你可使用特殊字符来创建这种正则表达式。例如，句点与除换行符外的其他字符都匹配，因此正则表达式'.ython'与字符串'python'和'jython'都匹配。它还与'qython'、'+ython'和'
     ython'（第一个字符为空格）等字符串匹配，但不与'cpython'、'ython'等字符串匹配，因为句点只与一个字符匹配，而不与零或两个字符匹配。
     句点与除换行符外的任何字符都匹配，因此被称为通配符（wildcard）。
   - 对特殊字符进行转义
     - 普通字符只与自己匹配，但特殊字符的情况完全不同。例如，假设要匹配字符串'python.org'，可以直接使用模式'python.org'吗？可以，但它也与'pythonzorg'匹配（还记得吗？句点与除换行符外的其他字符都匹配），这可能不是你想要的结果。要让特殊字符的行为与普通字符一样，可对其进行转义：像第1章对字符串中的引号进行转义时所做的那样，在它前面加上一个反斜杠。因此，在这个示例中，可使用模式'python\\.org'，它只与'python.org'匹配。
   - 字符集
     - 匹配任何字符很有用，但有时你需要更细致地控制。为此，可以用方括号将一个子串括起，创建一个所谓的字符集。这样的字符集与其包含的字符都匹配，例如'\[pj\]ython'与'python'和'jython'都匹配，但不与其他字符串匹配。你还可使用范围，例如'\[a-z\]'与a~z的任何字母都匹配。你还可组合多个访问，方法是依次列出它们，例如'\[a-zA-Z0-9\]'与大写字母、小写字母和数字都匹配。请注意，字符集只能匹配一个字符。
     要指定排除字符集，可在开头添加一个^字符，例如'\[^abc\]'与除a、b和c外的其他任何字符都匹配
   - 二选一和子模式
     - 需要以不同的方式处理每个字符时，字符集很好，但如果只想匹配字符串'python'和'perl'，该如何办呢？使用字符集或通配符无法指定这样的模式，而必须使用表示二选一的特殊字符：管道字符（|）。所需的模式为'python|perl'。
     然而，有时候你不想将二选一运算符用于整个模式，而只想将其用于模式的一部分。为此，可将这部分（子模式）放在圆括号内。对于前面的示例，可重写为'p(ython|erl)'。请注意，单个字符也可称为子模式。
   - 可选模式和重复模式
      - 通过在子模式后面加上问号，可将其指定为可选的，即可包含可不包含。例如，下面这个不太好懂的模式：

        ```
        r'(http://)?(www\.)?python\.org'
            只与下面这些字符串匹配
        'http://www.python.org' 
        'http://python.org' 
        'www.python.org' 
        'python.org'
        ```

     - 我对句点进行了转义，以防它充当通配符。
     - 为减少所需的反斜杠数量，我使用了原始字符串。
     - 每个可选的子模式都放在圆括号内。
     - 每个可选的子模式都可以出现，也可以不出现。
       问号表示可选的子模式可出现一次，也可不出现。还有其他几个运算符用于表示子模式可重
       复多次。
     - (pattern)*：pattern可重复0、1或多次。
     - (pattern)+：pattern可重复1或多次。
     - (pattern){m,n}：模式可从父m~n次。
   - 字符串的开头和末尾
     到目前为止，讨论的都是模式是否与整个字符串匹配，但也可查找与模式匹配的子串，如字符串'www.python.org'中的子串'www'与模式'w+'匹配。像这样查找字符串时，有时在整个字符串开头或末尾查找很有用。例如，你可能想确定字符串的开头是否与模式'ht+p'匹配，为此可使用脱字符（'^'）来指出这一点。例如，'^ht+p'与'http://python.org'和'htttttp://python.org'匹配，但与'www.http.org'不匹配。同样，要指定字符串末尾，可使用美元符号（$）。
2. 模块re的内容

   表10-9 模块re中一些重要的函数


   | 函 数                                  | 描 述                                              |
   | :------------------------------------- | :------------------------------------------------- |
   | compile(pattern\[, flags\])            | 根据包含正则表达式的字符串创建模式对象             |
   | search(pattern, string\[, flags\])     | 在字符串中查找模式                                 |
   | match(pattern, string\[, flags\])      | 在字符串开头匹配模式                               |
   | split(pattern, string\[, maxsplit=0\]) | 根据模式来分割字符串                               |
   | findall(pattern, string)               | 返回一个列表，其中包含字符串中所有与模式匹配的子串 |
   | sub(pat, repl, string\[, count=0\])    | 将字符串中与模式pat匹配的子串都替换为repl          |
   | escape(string)                         | 对字符串中所有的正则表达式特殊字符都进行转义       |


   - 函数re.compile将用字符串表示的正则表达式转换为模式对象，以提高匹配效率。调用search、match等函数时，如果提供的是用字符串表示的正则表达式，都必须在内部将它们转换为模式对象。通过使用函数compile对正则表达式进行转换后，每次使用它时都无需再进行转换。模式对象也有搜索/匹配方法，因此re.search(pat,
     string)（其中pat是一个使用字符串表示的正则表达式）等价于pat.search(string)（其中pat是使用compile创建的模式对象）。编译后的正则表达式对象也可用于模块re中的普通函数中。
   - 函数re.search在给定字符串中查找第一个与指定正则表达式匹配的子串。如果找到这样的子串，将返回MatchObject（结果为真），否则返回None（结果为假）。鉴于返回值的这种特征，可在条件语句中使用这个函数，如下所示：

     ```python
     if re.search(pat, string):
         print('Found it!')
     ```

     然而，如果你需要获悉有关匹配的子串的详细信息，可查看返回的MatchObject。下一节将更详细地介绍MatchObject。
   - 函数re.match尝试在给定字符串开头查找与正则表达式匹配的子串，因此re.match('p',
     'python')返回真（MatchObject），而re.match('p',
     'www.python.org')返回假（None）。
   - 函数re.split根据与模式匹配的子串来分割字符串。这类似于字符串方法split，但使用正则表达式来指定分隔符，而不是指定固定的分隔符。例如，使用字符串方法split时，可以字符串',
     '为分隔符来分割字符串，但使用re. split时，可以空格和逗号为分隔符来分割字符串。

     ```
     >>> some_text = 'alpha, beta,,,,gamma delta'
     >>> re.split('[, ]+', some_text) 
     ['alpha', 'beta', 'gamma', 'delta']  
     ```

     从这个示例可知，返回值为子串列表。参数maxsplit指定最多分割多少次

     ```
     >>> re.split('[, ]+', some_text, maxsplit=2)
     ['alpha', 'beta', 'gamma delta'] 
     >>> re.split('[, ]+', some_text, maxsplit=1) 
     ['alpha', 'beta,,,,gamma delta']
     ```
   - 函数re.findall返回一个列表，其中包含所有与给定模式匹配的子串。例如，要找出字符串包含的所有单词，可像下面这样做：

     ```
     >>> pat = '[a-zA-Z]+'
     >>> text = '"Hm... Err -- are you sure?" he said, sounding insecure.' 
     >>> re.findall(pat, text) 
     ['Hm', 'Err', 'are', 'you', 'sure', 'he', 'said', 'sounding', 'insecure'] 
     ```

     要查找所有的标点符号，可像下面这样做：

     ```
     >>> pat = r'[.?\-",]+'
     >>> re.findall(pat, text) 
     ['"', '...', '--', '?"', ',', '.'] 
     ```

     请注意，这里对连字符（-）进行了转义，因此Python不会认为它是用来指定字符范围的（如a-z）。
   - 函数re.sub从左往右将与模式匹配的子串替换为指定内容。请看下面的示例：

     ```
     >>> pat = '{name}'
     >>> text = 'Dear {name}...' 
     >>> re.sub(pat, 'Mr. Gumby', text) 
     'Dear Mr. Gumby...'
     ```
   - re.escape是一个工具函数，用于对字符串中所有可能被视为正则表达式运算符的字符进行转义。使用这个函数的情况有：字符串很长，其中包含大量特殊字符，而你不想输入大量的反斜杠；你从用户那里获取了一个字符串（例如，通过函数input），想将其用于正则表达式中。下面的示例说明了这个函数的工作原理：

     ```
     >>> re.escape('www.python.org')
     'www\\.python\\.org' 
     >>> re.escape('But where is the ambiguity?') 
     'But\\ where\\ is\\ the\\ ambiguity\\?'  
     ```
3. 匹配对象和编组

   在模块re中，查找与模式匹配的子串的函数都在找到时返回MatchObject对象。这种对象包含与模式匹配的子串的信息，还包含模式的哪部分与子串的哪部分匹配的信息。这些子串部分称为编组（group）。

   编组就是放在圆括号内的子模式，它们是根据左边的括号数编号的，其中编组0指的是整个模式。

   ```
   'There (was a (wee) (cooper)) who (lived in Fyfe)'
   ```

   包含如下编组：

   ```
   0 There was a wee cooper who lived in Fyfe 
   1 was a wee cooper 
   2 wee 
   3 cooper 
   4 lived in Fyfe
   ```

   表10-10 re匹配对象的重要方法


   | 方 法                  | 描 述                                                            |
   | :--------------------- | :--------------------------------------------------------------- |
   | group(\[group1, ...\]) | 获取与给定子模式（编组）匹配的子串                               |
   | start(\[group\])       | 返回与给定编组匹配的子串的起始位置              $$               |
   | end(\[group\])         | 返回与给定编组匹配的子串的终止位置（与切片一样，不包含终止位置） |
   | span(\[group\])        | 返回与给定编组匹配的子串的起始和终止位置                         |

   方法group返回与模式中给定编组匹配的子串。如果没有指定编组号，则默认为0。如果只指定了一个编组号（或使用默认值0），将只返回一个字符串；否则返回一个元组，其中包含与给定编组匹配的子串
   方法start返回与给定编组（默认为0，即整个模式）匹配的子串的起始索引。
   方法end类似于start，但返回终止索引加1
   方法span返回一个元组，其中包含与给定编组（默认为0，即整个模式）匹配的子串的起始索引和终止索引。


   ```
   >>> m = re.match(r'www\.(.*)\..{3}', 'www.python.org') 
   >>> m.group(1) 
   'python' 
   >>> m.start(1) 
   4 
   >>> m.end(1) 
   10 
   >>> m.span(1) 
   (4, 10)
   ```
4. 替换中的组号和函数

   ```
   >>> emphasis_pattern = r'\*([^\*]+)\*'

   >>> re.sub(emphasis_pattern, r'<em>\1</em>', 'Hello, *world*!') 
   'Hello, <em>world</em>!'
   ```
5. 找出发件人

   ```python
   # find_sender.py 
   import fileinput, re 
   pat = re.compile('From: (.*) <.*?>$') 
   for line in fileinput.input(): 
       m = pat.match(line) 
       if m: print(m.group(1))
   ```

   ```
   $ python find_sender.py message.eml 
   Foo Fie
   ```

   - 为提高处理效率，我编译了正则表达式。
   - 我将用于匹配要提取文本的子模式放在圆括号内，使其变成了一个编组。
   - 我使用了一个非贪婪模式，使其只匹配最后一对尖括号（以防姓名也包含尖括号）。
   - 我使用了美元符号指出要使用这个模式来匹配整行（直到行尾）。
   - 我使用了if语句来确保匹配后才提取与特定编组匹配的内容。

   ```python
   import fileinput, re 
   pat = re.compile(r'[a-z\-\.]+@[a-z\-\.]+', re.IGNORECASE) 
   addresses = set() 
   for line in fileinput.input(): 
       for address in pat.findall(line): 
       addresses.add(address) 
   for address in sorted(addresses): 
       print address
   ```

   ```
   Mr.Gumby@bar.baz 
   foo@bar.baz 
   foo@baz.com 
   magnus@bozz.floop
   ```
6. 模板系统示例

   模板（template）是一种文件，可在其中插入具体的值来得到最终的文本

   - 可使用正则表达式来匹配字段并提取其内容。
   - 可使用eval来计算表达式字符串，并提供包含作用域的字典。可在try/except语句中执行这种操作。如果出现SyntaxError异常，就说明你处理的可能是语句（如赋值语句）而不是表达式，应使用exec来执行它。
   - 可使用exec来执行语句字符串（和其他语句），并将模板的作用域存储到字典中。
   - 可使用re.sub将被处理的字符串替换为计算得到的结果。突然间，这看起来并不那么吓人了，不是吗？

   ```python
   # templates.py 
   import fileinput, re 
   # 与使用方括号括起的字段匹配
   field_pat = re.compile(r'\[(.+?)\]') 
   # 我们将把变量收集到这里：
   scope = {} 
   # 用于调用re.sub：
   def replacement(match): 
       code = match.group(1) 
       try: 
           # 如果字段为表达式，就返回其结果：
           return str(eval(code, scope)) 
       except SyntaxError: 
           # 否则在当前作用域内执行该赋值语句
           # 并返回一个空字符串
           return '' 
   # 获取所有文本并合并成一个字符串：
   #（还可采用其他办法来完成这项任务，详情请参见第11章）
   lines = [] 
   for line in fileinput.input(): 
       lines.append(line) 
   text = ''.join(lines) 
   # 替换所有与字段模式匹配的内容：
   print(field_pat.sub(replacement, text))  
   ```

   - 定义一个用于匹配字段的模式。
   - 创建一个用作模板作用域的字典。
   - 定义一个替换函数，其功能如下。
     - 从match中获取与编组1匹配的内容，并将其存储到变量code中。
     - 将作用域字典作为命名空间，并尝试计算code，再将结果转换为字符串并返回它。如果成功，就说明这个字段是表达式，因此万事大吉；否则（即引发了SyntaxError异常），就进入下一步。
     - 在对表达式进行求值时使用的命名空间（作用域字典）中执行这个字段，并返回一个空字符串（因为赋值语句没有结果）。
   - 使用fileinput读取所有的行，将它们放在一个列表中，再将其合并成一个大型字符串。
   - 调用re.sub来使用替换函数来替换所有与模式field_pat匹配的字段，并将结果打印出来。

#### 10.3.9 其他有趣的标准模块

- argparse：在UNIX中，运行命令行程序时常常需要指定各种选项（开关），Python解释器就是这样的典范。这些选项都包含在sys.argv中，但要正确地处理它们绝非容易。模块argparse使得提供功能齐备的命令行界面易如反掌。
- cmd：这个模块让你能够编写类似于Python交互式解释器的命令行解释器。你可定义命令，让用户能够在提示符下执行它们。或许可使用这个模块为你编写的程序提供用户界面？
- csv：CSV指的是逗号分隔的值（comma-seperated
  values），很多应用程序（如很多电子表格程序和数据库程序）都使用这种简单格式来存储表格数据。这种格式主要用于在不同的程序之间交换数据。模块csv让你能够轻松地读写CSV文件，它还以非常透明的方式处理CSV格式的一些棘手部分。
- datetime：如果模块time不能满足你的时间跟踪需求，模块datetime很可能能够满足。datetime支持特殊的日期和时间对象，并让你能够以各种方式创建和合并这些对象。相比于模块time，模块datetime的接口在很多方面都更加直观。
- difflib：这个库让你能够确定两个序列的相似程度，还让你能够从很多序列中找出与指定序列最为相似的序列。例如，可使用difflib来创建简单的搜索程序。
- enum：枚举类型是一种只有少数几个可能取值的类型。很多语言都内置了这样的类型，如果你在使用Python时需要这样的类型，模块enum可提供极大的帮助。
- functools：这个模块提供的功能是，让你能够在调用函数时只提供部分参数（部分求值，partial
  evaluation），以后再填充其他的参数。在Python
  3.0中，这个模块包含filter和reduce。
- hashlib：使用这个模块可计算字符串的小型“签名”（数）。计算两个不同字符串的签名时，几乎可以肯定得到的两个签名是不同的。你可使用它来计算大型文本文件的签名，这个模块在加密和安全领域有很多用途①。
- itertools：包含大量用于创建和合并迭代器（或其他可迭代对象）的工具，其中包括可以串接可迭代对象、创建返回无限连续整数的迭代器（类似于range，但没有上限）、反复遍历可迭代对象以及具有其他作用的函数。
- logging：使用print语句来确定程序中发生的情况很有用。要避免跟踪时出现大量调试输出，可将这些信息写入日志文件中。这个模块提供了一系列标准工具，可用于管理一个或多个中央日志，它还支持多种优先级不同的日志消息。
- statistics：计算一组数的平均值并不那么难，但是要正确地获得中位数，以确定总体标准偏差和样本标准偏差之间的差别，即便对于偶数个元素来说，也需要费点心思。在这种情况下，不要手工计算，而应使用模块statistics！
- timeit、profile和trace：模块timeit（和配套的命令行脚本）是一个测量代码段执行时间的工具。这个模块暗藏玄机，度量性能时你可能应该使用它而不是模块time。模块profile（和配套模块pstats）可用于对代码段的效率进行更全面的分析。模块trace可帮助你进行覆盖率分析（即代码的哪些部分执行了，哪些部分没有执行），这在编写测试代码时很有用。

### 10.4 小结

- 模块：模块基本上是一个子程序，主要作用是定义函数、类和变量等。模块包含测试代码时，应将这些代码放在一条检查name=='__main__'的if语句中。如果模块位于环境变量PYTHONPATH包含的目录中，就可直接导入它；要导入存储在文件foo.py中的模块，可使用语句import
  foo。
- 包：包不过是包含其他模块的模块。包是使用包含文件__init__.py的目录实现的。
- 探索模块：在交互式解释器中导入模块后，就可以众多不同的方式对其进行探索，其中包括使用dir、查看变量__all__以及使用函数help。文档和源代码也是获取信息和洞见的极佳来源。
- 标准库：Python自带多个模块，统称为标准库。本章介绍了其中的几个。
  - sys：这个模块让你能够访问多个与Python解释器关系紧密的变量和函数。
  - os：这个模块让你能够访问多个与操作系统关系紧密的变量和函数。
  - fileinput：这个模块让你能够轻松地迭代多个文件或流的内容行。
  - sets、heapq和deque：这三个模块提供了三种很有用的数据结构。内置类型set也实现了集合。
  - time：这个模块让你能够获取当前时间、操作时间和日期以及设置它们的格式。
  - random：这个模块包含用于生成随机数，从序列中随机地选择元素，以及打乱列表中元素的函数。
  - shelve：这个模块用于创建永久性映射，其内容存储在使用给定文件名的数据库中。
  - re：支持正则表达式的模块。

#### 10.4.1 本章介绍的新函数


| 函 数              | 描 述                                  |
| :----------------- | :------------------------------------- |
| dir(obj)           | 返回一个按字母顺序排列的属性名列表     |
| help(\[obj\])      | 提供交互式帮助或有关特定对象的帮助信息 |
| imp.reload(module) | 返回已导入的模块的重载版本             |

## 第11章 文件

### 11.1 打开文件

